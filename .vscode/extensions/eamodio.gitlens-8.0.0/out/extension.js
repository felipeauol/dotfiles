module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=4)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("fs")},function(e,t,i){"use strict";var s,o;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const r=s.length;for(let a=0;a<r;a++)e(t,`${i}[${a}]`,s[a],o);0===r&&(t[i]=null)}else{let r=!0;for(const a in s)r=!1,e(t,i?`${i}.${a}`:a,s[a],o);r&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const r=t[o];"object"==typeof r?s.push(...e(r,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(s||(s={})),function(e){function t(e,i,o=!0){if(void 0===e.children)return e;const r=[...s.values(e.children)];for(const e of r)t(e,i,!1);if(!o&&1===r.length){const t=r[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.makeHierarchical=function(e,i,s,o=!1){const r={name:"",relativePath:"",children:Object.create(null),descendants:[]},a=e.reduce((e,t)=>{let o=e,r="";for(const e of i(t)){r=s(r,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:r,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},r);return o?t(a,s,!0):a},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(o||(o={}));var r=i(5),a=i(6);const n=6e4,h=864e5;const c=a;c.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let r;return r="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+r:r+" ago":r}}}();const l={addSuffix:!0,locale:c};var d;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),r=s.getTime()-s.getTimezoneOffset()*n,a=o.getTime()-o.getTimezoneOffset()*n;return Math.round((r-a)/h)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(r.distanceInWordsToNow)(e,l),format:t=>Object(r.format)(e,t)}}}(d||(d={}));var m=i(2);const u=i(7),g=i(8);var p,f;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,r=m.__rest(s,["track"]);if(!0!==o)return u(e,t,r);let a=!1;const n=u(function(){return a=!1,e.apply(this,arguments)},t,i),h=function(){return a=!0,n.apply(this,arguments)};return h.pending=function(){return a},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return g(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(p||(p={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e){let t,i=0;for(;!(t=e.next()).done;)i++;return i},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(f||(f={}));class v{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}join(e){return e.join("")}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class w{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}join(e){return e.join("/")}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(t===w._fwd||t===w._bwd){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}w._fwd="/".charCodeAt(0),w._bwd="\\".charCodeAt(0);class C{isEmpty(){return void 0===this.left&&void 0===this.mid&&void 0===this.right&&void 0===this.element}}class b{constructor(e){this._iter=e}static forPaths(){return new b(new w)}static forStrings(){return new b(new v)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new C,this._root.str=i.value()),s=this._root;;){const e=i.cmp(s.str);if(e>0)s.left||(s.left=new C,s.left.str=i.value()),s=s.left;else if(e<0)s.right||(s.right=new C,s.right.str=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new C,s.mid.str=i.value()),s=s.mid}}const o=s.element;return s.element=t,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.element:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.element=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.element||i,s=s.mid}}return s&&s.element||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new b(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,[],e)}_forEach(e,t,i){void 0!==e&&(this._forEach(e.left,t,i),t.push(e.str),e.element&&i(e.element,this._iter.join(t)),this._forEach(e.mid,t,i),t.pop(),this._forEach(e.right,t,i))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(){return void 0===this._root||this._root.isEmpty()?0:f.count(this.entries())}entries(){return this._iterator(this._root,[])}values(){return f.map(this.entries(),e=>e[0])}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}*_iterator(e,t){void 0!==e&&(yield*this._iterator(e.left,t),t.push(e.str),e.element&&(yield[e.element,this._iter.join(t)]),yield*this._iterator(e.mid,t),t.pop(),yield*this._iterator(e.right,t))}}var y,x,S=i(9);!function(e){const t=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,i=/\$\{(\w*?)(?:\W|\d)*?\}/g;function s(e,t,i=" "){const s=t-h(e);return s<=0?e:i.repeat(s)+e}function o(e,t,i=" "){const s=t-h(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const i=[];let s=t.exec(e);for(;null!=s;){const o=s[2],r=s[3];i.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===r?"left":"right",collapseWhitespace:"?"===r}}),s=t.exec(e)}return i},e.interpolate=function(e,t){return e?void 0===t?e.replace(i,""):(e=e.replace(i,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(S.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(/\\/g,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=s,e.padLeftOrTruncate=function(e,t,i){const o=h(e);return o<t?s(e,t,i):o>t?a(e,t):e},e.padRight=o,e.padOrTruncate=function(e,t,i){const r=t<0;t=Math.abs(t);const n=h(e);return n<t?r?s(e,t,i):o(e,t,i):n>t?a(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=h(e);return s<t?o(e,t,i):s>t?a(e,t):e};const r=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function a(e,t,i="…"){if(!e)return e;const s=h(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),r=h(e.substring(0,o));for(;r<t;)r+=h(e[o++]);return r>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(r,t):e},e.sha1=function(e,t="base64"){return Object(S.createHash)("sha1").update(e).digest(t)},e.truncate=a;const n=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function h(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(n,"")];for(let e=0;e<o.length;e++){const r=o[e].codePointAt(0);if(!(r<=31||r>=127&&r<=159)&&!(r>=768&&r<=879))if(r>=128512&&r<=128591||r>=127744&&r<=128511||r>=128640&&r<=128767||r>=9728&&r<=9983||r>=9984&&r<=10175||r>=65024&&r<=65039||r>=129280&&r<=129535||r>=65024&&r<=65039||r>=8400&&r<=8447){if(r>=127995&&r<=127999)continue;i++,t+=2}else 8205!==r?(r>65535&&e++,t+=c(r)?2:1):(s++,t-=2)}const r=i-s;return r>1&&(t+=r-1),t}function c(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=h}(y||(y={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,r,a]=i.split(".");return t(o,r,a,s)}}(x||(x={}));var $,D,k,P,_,F,R,T,E,B,N,A,U,O=i(0);!function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}($||($={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}(D||(D={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(k||(k={})),function(e){e.Absolute="absolute",e.Relative="relative"}(P||(P={})),function(e){e.List="list",e.Tree="tree"}(_||(_={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(F||(F={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(R||(R={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(T||(T={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(E||(E={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(B||(B={})),function(e){e.Standard="standard",e.Chorded="chorded",e.None="none"}(N||(N={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(A||(A={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(U||(U={}));const L="gitlens",I="GitLens",W="GitLens",M="eamodio.gitlens",H=1e8;var j,G,V,Q,K,z;function q(e,t){return O.commands.executeCommand(j.SetContext,e,t)}function Y(e){const t=O.window.activeTextEditor;return void 0!==t&&t.document===e}function X(e){const t=e.document.uri.scheme;return t!==V.Output&&t!==V.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(j||(j={})),function(e){e.ActiveHasRemote="gitlens:activeHasRemote",e.ActiveIsBlameable="gitlens:activeIsBlameable",e.ActiveFileIsTracked="gitlens:activeIsTracked",e.ActiveIsRevision="gitlens:activeIsRevision",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(G||(G={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(V||(V={})),function(e){e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowLeft="←",e.ArrowLeftRight="↔",e.ArrowRight="→",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.DoubleArrowLeft="≪",e.DoubleArrowRight="⋘",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.Pensil="✎",e.Space=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(Q||(Q={})),function(e){e.GitLensVersion="gitlensVersion"}(K||(K={})),function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(z||(z={}));class J{}const Z=new class extends J{equals(e,t){return e===t}},ee=new class extends J{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?Z.equals(e.document,t.document):e.id===t.id)}},te=new class extends J{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var ie;!function(e){e.Computing="computing",e.Computed="computed"}(ie||(ie={}));class se extends O.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=se.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=O.Disposable.from(O.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(Z.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=p.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ie.Computing,e===O.window.activeTextEditor&&await q(G.AnnotationStatus,this.status),this.editor=e,this.correlationKey=se.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ie.Computed,e===O.window.activeTextEditor&&(await q(G.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ie.Computing,await this.onProvideAnnotation(e)?(this.status=ie.Computed,!0):(this.status=void 0,!1)}}const oe=`[${I}]`;class re{static configure(e){e.subscriptions.push(jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}static onConfigurationChanged(e){const t=jo.initializing(e);let i=jo.name("debug").value;(t||jo.changed(e,i))&&(this.debug=jo.get(i)),i=jo.name("outputLevel").value,(t||jo.changed(e,i))&&(this.level=jo.get(i),this.level===A.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||O.window.createOutputChannel(I))}static log(e,...t){this.debug&&console.log(this.timestamp,oe,e,...t),void 0===this.output||this.level!==A.Verbose&&this.level!==A.Debug||this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){this.debug&&console.error(this.timestamp,oe,t,e,...i),void 0!==this.output&&this.level!==A.Silent&&this.output.appendLine((this.debug?[this.timestamp,t,e,...i]:[t,e,...i]).join(" "))}static warn(e,...t){this.debug&&console.warn(this.timestamp,oe,e,...t),void 0!==this.output&&this.level!==A.Silent&&this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t){this.level===A.Debug&&(void 0===this.gitOutput&&(this.gitOutput=O.window.createOutputChannel(`${I} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})`))}}re.debug=!1,re.level=A.Silent;class ae extends O.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new O.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===Wo.git&&!await p.waitUntil(()=>void 0!==Wo.git,2e3))throw re.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Te.fromUri(e),this._disposed)return;const t=await Wo.git.getRepository(this._uri);return this._disposed?void 0:(this._repo=t,void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0}),t)}onRepositoryChanged(e){e.changed(Ve.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){q(G.ActiveIsRevision,this.isRevision),q(G.ActiveFileIsTracked,this.isTracked),q(G.ActiveIsBlameable,this.isBlameable),q(G.ActiveHasRemote,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,re.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&Y(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=O.window.activeTextEditor;return void 0!==t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await Wo.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemote(),void 0!==t){const s=this.isBlameable;if(q(G.ActiveIsRevision,this.isRevision),q(G.ActiveFileIsTracked,this.isTracked),q(G.ActiveIsBlameable,s),q(G.ActiveHasRemote,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class ne{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class he{constructor(e,t){this.commit=e,this.logCommit=t}}class ce extends O.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new O.EventEmitter,this._onDidChangeDirtyState=new O.EventEmitter,this._onDidTriggerDirtyIdle=new O.EventEmitter,this._documentMap=new Map,this._disposable=O.Disposable.from(jo.onDidChange(this.onConfigurationChanged,this),O.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveTextEditorChanged,0),this),O.workspace.onDidChangeTextDocument(p.debounce(this.onTextDocumentChanged,50),this),O.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),O.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(O.window.activeTextEditor)}onConfigurationChanged(e){const t=jo.initializing(e);if(!t&&(jo.changed(e,jo.name("blame")("ignoreWhitespace").value,null)||jo.changed(e,jo.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=jo.name("advanced")("blame")("delayAfterEdit").value;(t||jo.changed(e,i))&&(this._dirtyIdleTriggerDelay=jo.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!X(e))return;if(void 0===e)return q(G.ActiveIsRevision,!1),q(G.ActiveFileIsTracked,!1),q(G.ActiveIsBlameable,!1),void q(G.ActiveHasRemote,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==V.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=O.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?Y(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}async add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}async get(e){return await this._get(e)}async getOrAdd(e){return await this._get(e)||await this._add(e)}has(e){return("string"==typeof e||e instanceof O.Uri)&&(e=Te.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Te)try{e=await O.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){if(!t.toString().includes("File not found"))throw t;e=new le(e)}else e instanceof O.Uri&&(e=await O.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Te?e=Te.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof O.Uri)&&(e=Te.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Te.toKey(e.uri),i=new ae(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),O.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=p.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=p.debounce(async e=>{O.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class le{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=O.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}var de;function me(e){switch(e.type){case de.Branch:return"Branch";case de.Branches:return"Branches";case de.Commit:return"Commit";case de.File:return"File";case de.Repo:return"Repository";case de.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(de||(de={}));class ue{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return O.commands.executeCommand(j.Open,O.Uri.parse(e))}open(e){switch(e.type){case de.Branch:return this.openBranch(e.branch);case de.Branches:return this.openBranches();case de.Commit:return this.openCommit(e.sha);case de.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case de.Repo:return this.openRepo();case de.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}class ge extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("Bitbucket")}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}class pe extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("Bitbucket Server")}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class fe extends ue{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return y.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return y.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return y.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return y.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?y.interpolate(this.urls.fileLine,{line:s.start.line}):y.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?y.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?y.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):y.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}class ve extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitHub")}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}class we extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const Ce=new Map([["bitbucket.org",(e,t)=>new ge(e,t)],["github.com",(e,t)=>new ve(e,t)],["gitlab.com",(e,t)=>new we(e,t)],["visualstudio.com",(e,t)=>new class extends ue{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class be{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void re.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(Ce);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case k.Bitbucket:return(t,i)=>new ge(t,i,e.protocol,e.name,!0);case k.BitbucketServer:return(t,i)=>new pe(t,i,e.protocol,e.name,!0);case k.Custom:return(t,i)=>new fe(t,i,e.urls,e.protocol,e.name);case k.GitHub:return(t,i)=>new ve(t,i,e.protocol,e.name,!0);case k.GitLab:return(t,i)=>new we(t,i,e.protocol,e.name,!0)}}}var ye=i(10),xe=i(3),Se=i(1);const $e="win32"===process.platform;function De(e){if(e.match(/[\\\/]/))return e;const t=Se.join(".",e);try{if(xe.statSync(t))return t}catch(e){}const i=process.env.PATH.split($e?";":":");for(const t of i){const i=Se.join(t,e);try{if(xe.statSync(i))return i}catch(e){}}return e}function ke(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:r}=s,a=m.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(ye.execFile)(e,t,a,(o,r,n)=>{if(!o)return n&&re.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(r);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${a.maxBuffer} bytes`)),re.warn(`Error(${a.cwd}): ${e} ${t.join(" ")})\n    (${o.code}) ${o.message}\n${n}`),s(o)});o&&n.stdin.end(o,r||"utf8")})}async function Pe(e){const t=await ke(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!$e)return{cmd:De(t),args:i};if(!xe.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=De(`${t}${o}`);if(xe.existsSync(s))return e(s,i)}}if(t.match(/\.ps1$/i))return{cmd:Se.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)};if(t.match(/\.(bat|cmd)$/i))return{cmd:Se.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]};if(t.match(/\.(js)$/i))return{cmd:process.execPath,args:[t].concat(i)};return{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function _e(e){return e?Pe(Se.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}async function Fe(e){try{return await Pe(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await ke("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return Pe(e);try{return await ke("xcode-select",["-p"]),Pe(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):Pe(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await _e(process.env.ProgramW6432).then(null,()=>_e(process.env["ProgramFiles(x86)"])).then(null,()=>_e(process.env.ProgramFiles)).then(null,()=>Pe("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}var Re=i(11);class Te extends O.Uri{constructor(e,t){if(void 0===e)return void super();if(e.scheme===V.GitLensGit){const t=JSON.parse(e.query),[i,s]=Te.ensureValidUNCPath(e.authority,Se.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!Ot.isStagedUncommitted(t.sha)&&Ot.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Te.ensureValidUNCPath(e.authority,Se.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!Ot.isStagedUncommitted(t.sha)&&Ot.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&Ot.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?O.Uri.file(this.versionedPath):O.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getFormattedPath(e=y.pad(Q.Dot,2,2),t){let i=Se.dirname(this.fsPath);return this.repoPath&&(i=Se.relative(this.repoPath,i)),void 0!==t&&(i=Se.relative(t,i)),(i=y.normalizePath(i))&&"."!==i?`${Se.basename(this.fsPath)}${e}${i}`:Se.basename(this.fsPath)}getRelativePath(e){let t=Se.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=Se.relative(e,t)),y.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Te(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Te(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=O.Uri.file(Se.resolve(t,s&&e.originalFileName||e.fileName));return new Te(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Te(O.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Te(e)}static async fromUri(e){if(e instanceof Te)return e;if(!Wo.git.isTrackable(e))return new Te(e);if(e.scheme===V.GitLensGit)return new Te(e);if(e.scheme===V.Git){const t=JSON.parse(e.query),i=await Wo.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=Ot.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Te(e,{fileName:t.path,repoPath:i,sha:s})}const t=await Wo.git.getVersionedUri(e);return void 0!==t?t:new Te(e,await Wo.git.getRepoPath(e))}static getDirectory(e,t){let i=Se.dirname(e);return void 0!==t&&(i=Se.relative(t,i)),(i=y.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=y.pad(Q.Dot,2,2),i){let s;if(e instanceof O.Uri){if(e instanceof Te)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Te.getDirectory(s,i);return o?`${Se.basename(s)}${t}${o}`:Se.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof O.Uri){if(e instanceof Te)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=Se.relative(i||"",s);return void 0!==t&&(o=Se.relative(t,o)),y.normalizePath(o)}static toKey(e){return y.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,r;"string"==typeof e?(s="string"==typeof t?t:Se.resolve(i,t.fileName),o=e,r=Ot.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,r=e.shortSha);const a={fileName:y.normalizePath(Se.relative(i,s)),repoPath:i,sha:o},n=Se.parse(s);return O.Uri.parse(`${V.GitLensGit}:${Se.join(n.dir,n.name)}:${r}${n.ext}?${JSON.stringify(a)}`)}}const Ee=new Map;var Be;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Be||(Be={}));const Ne={dateFormat:void 0,dateStyle:void 0,reset:()=>{Ne.dateStyle=jo.get(jo.name("defaultDateStyle").value),Ne.dateFormat=jo.get(jo.name("defaultDateFormat").value)}};class Ae{constructor(e,t,i,s,o,r,a,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=r,this.message=a,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Ne.dateStyle===P.Absolute?this.formatDate(Ne.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=_t.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Be.Blame||this.type===Be.File||this.type===Be.StashFile}get isStash(){return this.type===Be.Stash||this.type===Be.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=_t.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=_t.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return _t.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&_t.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?O.Uri.file(Se.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return O.Uri.file(Se.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=d.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=d.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=y.pad(Q.Dot,2,2)){return Te.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Ee.get(i);if(void 0!==s)return s;const o=(s=O.Uri.parse(`https://www.gravatar.com/avatar/${this.email?y.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Ee.set(i,s),s}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await Wo.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Te.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ue extends Ae{constructor(e,t,i,s,o,r,a,n,h,c,l){super(Be.Blame,e,t,i,s,o,r,a,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ue(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Oe{constructor(e,t,i=!1,s,o=0,r=0){this.repoPath=e,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.current=i,this.name=t,this.tracking=""===s||null==s?void 0:s,this.state={ahead:o,behind:r}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Oe.getRemote(this.name):void 0!==this.tracking?Oe.getRemote(this.tracking):void 0}isValid(){return Oe.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Le=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Ie=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,We=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class Me{static parse(e,t=!1){if(!e)return;const i=[];let s,o,r,a=null;do{if(null==(a=We.exec(`${e}\n@@`)))break;s=(" "+a[5]).substr(1),o=parseInt(a[3],10),r=parseInt(a[1],10),i.push(new He(s,{start:o,end:o+parseInt(a[4],10)},{start:r,end:r+parseInt(a[2],10)}))}while(null!=a);if(!i.length)return;return{diff:t?e:void 0,chunks:i}}static parseChunk(e){const t=f.skip(y.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const r=[];let a=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))a={line:n.line,state:n.state,previous:[s[e]]},r.push(a);else{if(void 0===a)continue;if(void 0===a.previous){a.previous=[s[e]];continue}a.previous.push(s[e])}return r}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Le.exec(e)))break;i.push(vt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Ie.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class He{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=Me.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class je extends Ae{constructor(e,t,i,s,o,r,a,n,h,c,l,d,m,u){super(e,t,i,s,o,r,a,n,l,d,m),this.fileStatuses=h,this.status=c,this.parentShas=u}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&_t.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?O.Uri.file(Se.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=y.normalizePath(Se.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Be.StashFile:Be.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new je(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ge,Ve,Qe;!function(e){e.Fetch="fetch",e.Push="push"}(Ge||(Ge={}));class Ke{constructor(e,t,i,s,o,r){this.repoPath=e,this.name=t,this.domain=i,this.path=s,this.provider=o,this.types=r}}!function(e){e.Config="config",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(Ve||(Ve={}));class ze{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}!function(e){e.StatusNode="statusNode"}(Qe||(Qe={}));class qe extends O.Disposable{constructor(e,t,i,s,o){super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new O.EventEmitter,this._onDidChangeFileSystem=new O.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this.formattedName=i?e.name:`${e.name} (${Se.relative(e.uri.fsPath,t)})`,this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o;const r=O.workspace.createFileSystemWatcher(new O.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=O.Disposable.from(r,r.onDidChange(this.onRepositoryChanged,this),r.onDidCreate(this.onRepositoryChanged,this),r.onDidDelete(this.onRepositoryChanged,this),jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=jo.initializing(e),i=jo.name("remotes").value;(t||jo.changed(e,i,this.folder.uri))&&(this._providerMap=be.createMap(jo.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(Ve.Remotes)))}onFileSystemChanged(e){/\.git/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(Ve.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(Ve.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(Ve.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(Ve.Config,Ve.Remotes);this.onAnyRepositoryChanged(this),this.fireChange(Ve.Repository)}}}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=p.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new ze(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=p.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}containsUri(e){return e instanceof Te&&(e=void 0!==e.repoPath?O.Uri.file(e.repoPath):e.fileUri()),this.folder===O.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=Wo.git.getBranch(this.path)),this._branch}getBranches(){return Wo.git.getBranches(this.path)}getChangedFilesCount(e){return Wo.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=jo.get(jo.name("remotes").value,this.folder.uri);this._providerMap=be.createMap(e)}this._remotes=Wo.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return Wo.git.getStashList(this.path)}getStatus(){return Wo.git.getStatusForRepo(this.path)}getTags(){return Wo.git.getTags(this.path)}async hasRemote(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=O.workspace.createFileSystemWatcher(new O.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=O.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}}class Ye extends je{constructor(e,t,i,s,o,r,a,n,h,c,l,d){super(e,i,s,"You",void 0,o,r,a,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new Ye(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class Xe{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return O.Uri.file(Se.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return Xe.getFormattedDirectory(this,e)}getFormattedPath(e=y.pad(Q.Dot,2,2)){return Xe.getFormattedPath(this,e)}getOcticon(){return Ze(this.status)}with(e){return new Xe(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Te.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${y.pad(Q.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=y.pad(Q.Dot,2,2),i){return Te.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Te.getRelativePath(e.fileName,t)}}const Je={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function Ze(e,t=Q.Space.repeat(4)){return Je[e]||t}const et={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function tt(e){return et[e]||et.X}class it{constructor(e,t){this.repoPath=e,this.name=t}}class st{static parse(e,t,i){if(!e)return;const s=new Map,o=new Map,r=[];let a,n,h=t&&i,c=void 0,l=!0;for(a of y.lines(e))if(!((n=a.split(" ")).length<2))if(void 0!==c)switch(n[0]){case"author":c.author=_t.isUncommitted(c.sha)?"You":n.slice(1).join(" ").trim();break;case"author-mail":c.authorEmail=n.slice(1).join(" ").trim();const e=c.authorEmail.indexOf("<");if(e>=0){const t=c.authorEmail.indexOf(">",e);c.authorEmail=t>e?c.authorEmail.substring(e+1,t):c.authorEmail.substring(e+1)}break;case"author-time":c.authorDate=n[1];break;case"author-tz":c.authorTimeZone=n[1];break;case"summary":c.summary=n.slice(1).join(" ").trim();break;case"previous":c.previousSha=n[1],c.previousFileName=n.slice(2).join(" ");break;case"filename":c.fileName=n.slice(1).join(" "),l&&void 0===t&&(t=y.normalizePath(i.replace(i.startsWith("/")?`/${c.fileName}`:c.fileName,"")),h=y.normalizePath(Se.relative(t,i))),l=!1,st.parseEntry(c,t,h,o,s,r),c=void 0}else c={sha:n[0],originalLine:parseInt(n[1],10)-1,line:parseInt(n[2],10)-1,lineCount:parseInt(n[3],10)};return o.forEach(e=>{if(void 0===e.author)return;const t=s.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...s.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:o,lines:r}}static parseEntry(e,t,i,s,o,r){let a=s.get(e.sha);if(void 0===a){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}a=new Ue(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,a)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};a.previousSha&&(i.previousSha=a.previousSha),a.lines.push(i),r[i.line]=i}}}const ot=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,rt=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class at{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=ot.exec(e)))break;const[o,r]=this.parseState(s[5]);i.push(new Oe(t,s[2],"*"===s[1],s[4],o,r))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=rt.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const nt=/diff --git a\/(.*) b\/(.*)/,ht={};class ct{static parse(e,t,i,s,r,a,n,h){if(!e)return;let c,l,d=void 0,m=ht,u=void 0,g=0,p=!0;const f=y.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=y.normalizePath(i));const w=new Map,C=new Map;for(;!((v=f.next()).done||(u=v.value,n&&a&&g>=a));)switch(l=u.charCodeAt(1)){case 114:m={ref:u.substring(4)};break;case 97:m.author=_t.isUncommitted(m.ref)?"You":u.substring(4);break;case 101:m.email=u.substring(4);break;case 100:m.date=u.substring(4);break;case 112:m.parentShas=u.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(u=v.value);)void 0===m.summary?m.summary=u:m.summary+=`\n${u}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(u=v.value);)if(!u.startsWith("warning:"))if(t===Be.Branch){const e={status:u[0],fileName:u.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(u.startsWith("diff")){const e=nt.exec(u);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}m.status=u[0],m.fileName=u.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=o.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Be.File&&void 0!==s?(i=y.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),c=y.normalizePath(Se.relative(i,s))):c=m.fileName,p=!1;const e=C.get(m.ref);void 0===e&&g++,d=ct.parseEntry(m,e,t,i,c,C,w,d)}return{repoPath:i,authors:w,commits:C,sha:r,count:g,maxCount:a,range:h,truncated:!!(a&&g>=a&&1!==a)}}static parseEntry(e,t,i,s,o,r,a,n){if(void 0===t){if(void 0!==e.author){let t=a.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},a.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Be.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new je(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),r.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Be.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const lt=/^(.*)\t(.*)\s\((.*)\)$/gm,dt=/^(?:git:\/\/(.*?)\/|https:\/\/(.*?)\/|http:\/\/(.*?)\/|git@(.*):|ssh:\/\/(?:.*@)?(.*?)(?::.*?)?\/)(.*)$/;class mt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let r=null;do{if(null==(r=lt.exec(e)))break;const a=r[2],[n,h]=this.parseGitUrl(a),c=`${n}/${h}`;let l=o[c];void 0===l?(l=new Ke(t,r[1],n,h,i(n,h),[{url:a,type:r[3]}]),s.push(l),o[c]=l):l.types.push({url:a,type:r[3]})}while(null!=r);return s.length?s:[]}static parseGitUrl(e){const t=dt.exec(e);return null==t?["",""]:[t[1]||t[2]||t[3]||t[4]||t[5],t[6].replace(/\.git\/?$/,"")]}}const ut={};class gt{static parse(e,t){if(!e)return;const i=y.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=y.normalizePath(t));const r=new Map;let a,n=ut,h=void 0;for(;!(s=i.next()).done;)switch(a=(h=s.value).charCodeAt(1)){case 114:n={ref:h.substring(4)};break;case 100:n.date=h.substring(4);break;case 108:n.stashName=h.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(h=s.value);)void 0===n.summary?n.summary=h:n.summary+=`\n${h}`;void 0!==n.summary&&(n.summary=n.summary.slice(0,-1));break;case 102:if((s=i.next()).done||"</f>"===s.value)break;for(;!(s=i.next()).done&&"</f>"!==(h=s.value);){if(h.startsWith("warning:"))continue;const e={status:h[0],fileName:h.substring(1),originalFileName:void 0};ct.parseFileName(e),e.fileName&&(void 0===n.fileStatuses&&(n.fileStatuses=[]),n.fileStatuses.push(e))}void 0!==n.fileStatuses&&(n.fileNames=o.filterMap(n.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "));let e=r.get(n.ref);e=gt.parseEntry(n,e,t,r)}return{repoPath:t,commits:r}}static parseEntry(e,t,i,s){return void 0===t&&(t=new Ye(Be.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const pt=/(?:ahead ([0-9]+))/,ft=/(?:behind ([0-9]+))/;class vt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let r,a=-1;for(;++a<e.length;){const n=e[a];if(n.startsWith("##")){const e=n.split(" ");if([i,r]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=pt.exec(t);o.ahead=null==i?0:+i[1]||0;const s=ft.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,r]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,r.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return{branch:i||"",repoPath:y.normalizePath(t),sha:"",state:o,files:s,upstream:r}}static parseV2(e,t){let i;const s=[];let o;const r={ahead:0,behind:0};let a,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":a=e[2];break;case"branch.ab":r.ahead=+e[2].substring(1),r.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return{branch:i||"",repoPath:y.normalizePath(t),sha:o||"",state:r,files:s,upstream:a}}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let r=void 0;return t.length>1&&(""!==(r="."!==t[1]?t[1].trim():void 0)&&null!==r||(r=void 0)),new Xe(e,o,r,i,s)}}class wt{static parse(e,t){if(!e)return;const i=o.filterMap(e.split("\n"),e=>e?new it(t,e):void 0);return i.length?i:void 0}}let Ct;const bt=["blame","--root","--incremental"],yt=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],xt=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],St=[/Not a git repository/,/is outside repository/,/no such path/,/does not have any commits/,/Path \'.*?\' does not exist in/,/Path \'.*?\' exists on disk, but not in/,/no upstream configured for branch/,/ambiguous argument '.*?': unknown revision or path not in the working tree/];async function $t(e,...t){try{return await kt(e,...t)}catch(i){return Pt(i,e,...t)}}const Dt=new Map;async function kt(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=m.__rest(e,["correlationKey"]),r=e.encoding||"utf8",a=Object.assign({},o,{encoding:"utf8"===r?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE"})}),n=`git ${t.join(" ")}`,h=`(${a.cwd}${void 0!==s?s:""}): ${n}`;let c,l=Dt.get(h);void 0===l?(re.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),l=ke(Ct.path,t,a),Dt.set(h,l)):re.log(`Awaiting${h}`);try{c=await l}finally{Dt.delete(h);const e=process.hrtime(i),t=`in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;re.log(`Completed${h} ${t}`),re.logGitCommand(`${n} ${t}`,a.cwd)}return"utf8"===r||"binary"===r?c:Re.decode(Buffer.from(c,"binary"),r)}function Pt(e,t,...i){const s=e&&e.toString();if(s)for(const e of St)if(e.test(s))return re.warn("git",...i,`  cwd='${t.cwd}'`,`\n  ${s.replace(/\r?\n|\r/g," ")}`),"";throw re.error(e,"git",...i,`  cwd='${t.cwd}'`,s&&`\n  ${s.replace(/\r?\n|\r/g," ")}`),e}class _t{static gitInfo(){return Ct}static getEncoding(e){return void 0!==e&&Re.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Ct=await Fe(e);const i=process.hrtime(t);return re.log(`Git found: ${Ct.version} @ ${"git"===Ct.path?"PATH":Ct.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Ct}static async getVersionedFile(e,t,s){const o=await _t.show(e,t,s,{encoding:"binary"});if(void 0===o)return;_t.isStagedUncommitted(s)&&(s="");const r=y.truncate(y.sanitizeForFileSystem(_t.isSha(s)?_t.shortenSha(s):s),50,""),a=Se.extname(t),n=await new Promise(function(e){e()}).then(i.bind(null,12));return new Promise((i,h)=>{n.file({prefix:`${Se.basename(t,a)}-${r}__`,postfix:a},(r,a,n,c)=>{r?h(r):(re.log(`getVersionedFile[${a}]('${e}', '${t}', ${s})`),xe.appendFile(a,o,{encoding:"binary"},e=>{e?h(e):i(a)}))})})}static isResolveRequired(e){return _t.isSha(e)&&!_t.shaStrictRegex.test(e)}static isSha(e){return _t.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&_t.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&_t.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({uncommitted:"",stagedUncommitted:"index"},t),_t.isStagedUncommitted(e))return t.stagedUncommitted;if(_t.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=y.normalizePath(e);const i=((t=y.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=y.normalizePath(i?Se.dirname(e):t),e=y.normalizePath(i?Se.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Ct.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,r]=_t.splitPath(t,e),a=[...bt];let n;return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),i&&(_t.isStagedUncommitted(i)?(a.push("--contents","-"),n=await _t.show(e,t,":")):a.push(i)),$t({cwd:r,stdin:n},...a,"--",o)}static async blame_contents(e,t,i,s={}){const[o,r]=_t.splitPath(t,e),a=[...bt];return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),a.push("--contents","-"),$t({cwd:r,stdin:i,correlationKey:s.correlationKey},...a,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),$t({cwd:e},...i)}static checkout(e,t,i){const[s,o]=_t.splitPath(t,e);return $t({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await kt({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const r=["diff","--diff-filter=M","-M","--no-ext-diff"];return i&&r.push(_t.isStagedUncommitted(i)?"--staged":i),s&&r.push(_t.isStagedUncommitted(s)?"--staged":s),$t({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...r,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),$t({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),$t({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),$t({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),$t({cwd:e},...o)}static log(e,t){const i=[...yt,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!_t.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),$t({cwd:e},...i)}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=_t.splitPath(t,e),r=[...yt];return i.maxCount&&!i.reverse&&r.push(`-n${i.maxCount}`),i.renames&&r.push("--follow","-m","--first-parent"),i.ref&&!_t.isStagedUncommitted(i.ref)&&(i.reverse?r.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):r.push(i.ref)),null!=i.startLine&&null!=i.endLine&&r.push(`-L ${i.startLine},${i.endLine}:${s}`),r.push("--",s),$t({cwd:o},...r)}static async log_recent(e,t){try{return(await kt({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await kt({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...yt,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),$t({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!_t.isStagedUncommitted(t.ref)&&i.push(t.ref),$t({cwd:e},...i)}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!_t.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await kt({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),$t({cwd:e},...o,t,i)}static remote(e){return $t({cwd:e},"remote","-v")}static remote_url(e,t){return $t({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await kt({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await kt(i,...t)}catch(e){const s=e&&e.toString();if(/HEAD does not point to a branch/.test(s))return;if(/no upstream configured for branch/.test(s))return e.message.split("\n")[0];if(/ambiguous argument '.*?': unknown revision or path not in the working tree/.test(s))try{const e=["symbolic-ref","-q","--short","HEAD"];return await kt(i,...e)}catch(e){return}return Pt(e,i,...t)}}static async revparse_toplevel(e){try{return(await kt({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,r]=_t.splitPath(t,e);if(_t.isStagedUncommitted(i)&&(i=":"),_t.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const a={cwd:r,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await kt(a,"show",n)}catch(e){const t=e&&e.toString();if(/Path \'.*?\' does not exist in/.test(t)||/Path \'.*?\' exists on disk, but not in /.test(t))return;return Pt(e,a,n)}}static stash_apply(e,t,i){if(t)return $t({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return $t({cwd:e},"stash","drop",t)}static stash_list(e){return $t({cwd:e},...xt)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),$t({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),$t({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return $t({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=_t.splitPath(t,e),r=i>=2?`--porcelain=v${i}`:"--porcelain";return $t({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",r,s)}static tag(e){return $t({cwd:e},...["tag","-l"])}}_t.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,_t.shaStrictRegex=/^[0-9a-f]{40}$/,_t.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,_t.stagedUncommittedSha="0000000000000000000000000000000000000000:",_t.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,_t.uncommittedSha="0000000000000000000000000000000000000000";class Ft{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=y.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:y.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?y.padLeft(e,i):(t.collapseWhitespace&&(i-=o),y.padRight(e,i))):o<0?y.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof Ft)return y.interpolate(t,e);let o=void 0;if(null==s||"string"==typeof s){o={dateFormat:s,tokenOptions:y.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}}else o=s;return void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),y.interpolate(t,this._formatter)}}Ft._formatter=void 0;class Rt extends Ft{get ago(){const e=this._item.fromNow();return this._padOrTruncate(e,this._options.tokenOptions.ago)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._item.fromNow()}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){const e=this._item.formatDate(this._options.dateFormat);return this._padOrTruncate(e,this._options.tokenOptions.date)}get id(){return this._item.isUncommitted&&!this._item.isStagedUncommitted?"00000000":this._item.shortSha}get message(){let e=this._item.isUncommitted?"Uncommitted change":this._item.message;if(this._options.truncateMessageAtNewLine){const t=e.indexOf("\n");-1!==t&&(e=`${e.substring(0,t)}${Q.Space}${Q.Ellipsis}`)}return this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Tt extends Ft{get directory(){const e=Xe.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=Se.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=Xe.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=Xe.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${Q.Pensil} ${Q.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Et,Bt,Nt,At,Ut;!function(e){e.Author="author",e.ChangedOccurrences="changed-occurrences",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Et||(Et={}));class Ot extends O.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new O.EventEmitter,this._suspended=!1,this._repositoryTree=b.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=O.Disposable.from(O.window.onDidChangeWindowState(this.onWindowStateChanged,this),O.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return Wo.config.advanced.caching.enabled}onAnyRepositoryChanged(e){this._trackedCache.clear()}onConfigurationChanged(e){(jo.initializing(e)||jo.changed(e,jo.name("defaultDateStyle").value)||jo.changed(e,jo.name("defaultDateFormat").value))&&Ne.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:O.workspace.workspaceFolders||[],removed:[]},re.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==V.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==V.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...f.map(i.entries(),([t,i])=>[t,Se.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=jo.get(jo.name("advanced")("repositorySearchDepth").value,t);re.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),r=[],a=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(re.log(`Repository found in '${n}'`),r.push(new qe(e,n,!0,a,this._suspended))),i<=0){const e=process.hrtime(o);return re.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),r}let h=Object.assign({},O.workspace.getConfiguration("files",t).get("exclude",{}),O.workspace.getConfiguration("search",t).get("exclude",{}));h=[...f.filterMap(s.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const c=await this.repositorySearchCore(t.fsPath,i,h);for(let t of c){if(t=Se.dirname(t),y.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(re.log(`Repository found in '${i}'`),r.push(new qe(e,i,!1,a,this._suspended)))}const l=process.hrtime(o);return re.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*l[0]+Math.floor(l[1]/1e6)} ms`),r}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,r)=>{xe.readdir(e,async(a,n)=>{if(null!=a)return void r(a);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=Se.resolve(e,t);return new Promise((e,r)=>{xe.stat(o,(r,a)=>{".git"===t?s.push(o):null==r&&!0!==i[t]&&null!=a&&a.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await q(G.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await q(G.HasRemotes,i),!t){const e=O.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=O.Disposable.from(e,e.onDidCreate(async e=>{const i=O.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,re.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),_t.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>xe.exists(Se.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&f.first(s.commits.values());if(o)return o;const r=await this.findNextFileName(e,t,i);return r&&(o=(s=await this.getLogForFile(e,r,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&f.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=_t.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=f.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=_t.splitPath(s,t)):s=y.normalizePath(Se.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){if(void 0===e){const e=this.getHighlanderRepoPath();if(void 0!==e)return e}if(void 0===(e=e||O.window.activeTextEditor))return;const t=await Wo.tracker.getOrAdd(e.document.uri);return void 0!==t?t.uri.repoPath:void 0}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await Wo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return re.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}re.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new ne(i.key))}else re.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(re.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return re.log(`Skipping blame; '${e.fsPath}' is not tracked`),Ot.emptyPromise;const[s,o]=_t.splitPath(e.fsPath,e.repoPath,!1);try{const r=await _t.blame(o,s,e.sha,{ignoreWhitespace:Wo.config.blame.ignoreWhitespace});return st.parse(r,o,s)}catch(e){if(void 0!==t.state){const s=e&&e.toString();return re.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:Ot.emptyPromise,errorMessage:s}),t.setBlameFailure(),Ot.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${y.sha1(t)}`,s=await Wo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return re.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}re.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new ne(s.key))}else re.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(re.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return re.log(`Skipping blame; '${e.fsPath}' is not tracked`),Ot.emptyPromise;const[o,r]=_t.splitPath(e.fsPath,e.repoPath,!1);try{const e=await _t.blame_contents(r,o,t,{correlationKey:`:${s}`,ignoreWhitespace:Wo.config.blame.ignoreWhitespace});return st.parse(e,r,o)}catch(e){if(void 0!==i.state){const t=e&&e.toString();return re.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:Ot.emptyPromise,errorMessage:t}),i.setBlameFailure(),Ot.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(re.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await _t.blame(e.repoPath,o,e.sha,{ignoreWhitespace:Wo.config.blame.ignoreWhitespace,startLine:s,endLine:s}),r=st.parse(i,e.repoPath,o);if(void 0===r)return;return{author:f.first(r.authors.values()),commit:f.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(re.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const r=s.commits.get(o.sha);if(void 0===r)return;return{author:Object.assign({},s.authors.get(r.author),{lineCount:r.lines.length}),commit:r,line:o}}const o=t+1,r=e.fsPath;try{const s=await _t.blame_contents(e.repoPath,r,i,{ignoreWhitespace:Wo.config.blame.ignoreWhitespace,startLine:o,endLine:o}),a=st.parse(s,e.repoPath,r);if(void 0===a)return;return{author:f.first(a.authors.values()),commit:f.first(a.commits.values()),line:a.lines[t]}}catch(e){return}}async getBlameForRange(e,t){re.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(re.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),r=new Map,a=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});a.set(t.sha,e);let s=r.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},r.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...r.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;re.log(`getBranch('${e}')`);const t=await _t.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Oe(e,i[0],!0,i[1])}async getBranches(e){if(void 0===e)return[];re.log(`getBranches('${e}')`);const t=await _t.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return at.parse(t,e)||[]}async getChangedFilesCount(e,t){re.log(`getChangedFilesCount('${e}', '${t}')`);const i=await _t.diff_shortstat(e,t);return Me.parseShortStat(i)}async getConfig(e,t){return re.log(`getConfig('${e}', '${t}')`),await _t.config_get(e,t)}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await Wo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return re.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),r.item}re.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new ne(o.key))}else re.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const r=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:Ot.getEncoding(e)},o,s);return void 0!==o.state&&(re.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getDiffForFileCore(e,t,i,s,o,r,a){const[n,h]=_t.splitPath(t,e,!1);try{const e=await _t.diff(h,n,i,s,o);return Me.parse(e)}catch(e){if(void 0!==r.state){const t=e&&e.toString();return re.log(`Replace diff cache with empty promise for '${r.state.key}:${a}'`),r.state.set(a,{item:Ot.emptyPromise,errorMessage:t}),Ot.emptyPromise}return}}async getDiffForLine(e,t,i,s){re.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const r=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===r)return;return r.lines[t-r.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){re.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await _t.diff_nameStatus(e,t,i,s);return Me.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await _t.log_recent(e,t)}async getLogCommit(e,t){re.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){re.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||_t.isResolveRequired(i.ref)?o||f.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),re.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?Wo.config.advanced.maxListItems||0:t.maxCount;try{const s=await _t.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=ct.parse(s,Be.Branch,e,void 0,t.ref,i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){re.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?Wo.config.advanced.maxListItems||0:s.maxCount,r=void 0;switch(i){case Et.Author:r=[`--author=${t}`];break;case Et.ChangedOccurrences:r=[`-S${t}`,"--pickaxe-regex"];break;case Et.Changes:r=[`-G${t}`];break;case Et.Files:r=["--",`${t}`];break;case Et.Message:r=[`--grep=${t}`];break;case Et.Sha:r=[t],o=1}try{const a=await _t.log_search(e,r,{maxCount:o}),n=ct.parse(a,Be.Branch,e,void 0,void 0,o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===y.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=Wo.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await Wo.tracker.getOrAdd(new Te(O.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return re.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;if("log"!==s){const r=o.state.get("log");if(void 0!==r){if(void 0===i.ref)return re.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;re.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await r.item;if(void 0!==o&&o.commits.has(i.ref))return re.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item}}}re.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new ne(o.key))}else re.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(re.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return re.log(`Skipping log; '${t}' is not tracked`),Ot.emptyPromise;const[r,a]=_t.splitPath(t,e,!1);try{const{range:n}=i,h=m.__rest(i,["range"]),c=null==i.maxCount?Wo.config.advanced.maxListItems||0:i.maxCount,l=await _t.log_file(a,r,Object.assign({},h,{maxCount:c,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),d=ct.parse(l,Be.File,a,r,h.ref,c,h.reverse,n);if(void 0!==d){const s=Object.assign({},i);d.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return d}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return re.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:Ot.emptyPromise,errorMessage:t}),Ot.emptyPromise}return}}async hasRemote(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemote()}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async getMergeBase(e,t,i,s={}){try{const o=await _t.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void re.error(e,"GitService.getMergeBase")}}async getRemotes(e){if(void 0===e)return[];re.log(`getRemotes('${e}')`);const t=await this.getRepository(e);return void 0!==t?t.getRemotes():this.getRemotesCore(e)}async getRemotesCore(e,t){if(void 0===e)return[];re.log(`getRemotesCore('${e}')`),t=t||be.createMap(jo.get(jo.name("remotes").value,null));try{const i=await _t.remote(e);return mt.parse(i,e,be.factory(t))}catch(e){return re.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(void 0===e)return await this.getActiveRepoPath();if(e instanceof Te)return e.repoPath;const i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s),r=void 0===o?O.workspace.getWorkspaceFolder(O.Uri.file(s)):o.folder;if(void 0!==r){const e=new qe(r,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended);this._repositoryTree.set(s,e),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}return s}async getRepoPathCore(e,t){try{return await _t.revparse_toplevel(t?e:Se.dirname(e))}catch(e){return void re.error(e,"GitService.getRepoPathCore")}}async getRepositories(){return(await this.getRepositoryTree()).values()}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Te){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;re.log(`getStashList('${e}')`);const t=await _t.stash_list(e);return gt.parse(t,e)}async getStatusForFile(e,t){re.log(`getStatusForFile('${e}', '${t}')`);const i=_t.validateVersion(2,11)?2:1,s=await _t.status_file(e,t,i),o=vt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;re.log(`getStatusForRepo('${e}')`);const t=_t.validateVersion(2,11)?2:1,i=await _t.status(e,t);return vt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];re.log(`getTags('${e}')`);const t=await _t.tag(e);return wt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(re.log(`getVersionedFile('${e}', '${t}', '${i}')`),!i||_t.isUncommitted(i)&&!_t.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await _t.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Te.toKey(s),new Te(O.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return re.log(`getVersionedFileText('${e}', '${t}', ${i})`),_t.show(e,t,i,{encoding:Ot.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Te.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===V.File||t===V.Git||t===V.GitLensGit}async isTracked(e,t,i={}){if(i.ref===Ot.deletedSha)return!1;let s,o,r=i.ref;if("string"==typeof e)[o,t]=_t.splitPath(e,t),s=Te.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,r=e.sha,s=Te.toKey(o)}void 0!==r&&(s+=`:${r}`),re.log(`isTracked('${o}', '${t}', '${r}')`);let a=this._trackedCache.get(s);return void 0!==a?await a:(a=this.isTrackedCore(o,void 0===t?"":t,r),i.skipCacheUpdate?a:(this._trackedCache.set(s,a),a=await a,this._trackedCache.set(s,a),a))}async isTrackedCore(e,t,i){if(i===Ot.deletedSha)return!1;try{let s=!!await _t.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await _t.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await _t.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return re.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await _t.config_get("diff.guitool",e)||await _t.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return re.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),_t.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return re.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),_t.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return Ot.isResolveRequired(t)?(re.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),void 0===i?await _t.revparse(e,t)||t:await _t.log_resolve(e,y.normalizePath(Se.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return re.log(`stashApply('${e}', '${t}', ${i})`),_t.stash_apply(e,t,i)}stashDelete(e,t){return re.log(`stashDelete('${e}', '${t}')`),_t.stash_delete(e,t)}stashSave(e,t,i){if(re.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return _t.stash_save(e,t);const s=i.map(t=>_t.splitPath(t.fsPath,e)[0]);return _t.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?O.Uri.file(Se.join(e,t)):e;return _t.getEncoding(O.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return _t.getGitInfo(e)}static getGitPath(){return _t.gitInfo().path}static getGitVersion(){return _t.gitInfo().version}static isResolveRequired(e){return _t.isResolveRequired(e)}static isSha(e){return _t.isSha(e)}static isStagedUncommitted(e){return _t.isStagedUncommitted(e)}static isUncommitted(e){return _t.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)"},t),e===Ot.deletedSha?t.deleted:_t.isSha(e)||_t.isStagedUncommitted(e)?_t.shortenSha(e,t):e}static validateGitVersion(e,t){const[i,s]=this.getGitVersion().split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}}Ot.emptyPromise=Promise.resolve(void 0),Ot.deletedSha="ffffffffffffffffffffffffffffffffffffffff",Ot.stagedUncommittedSha=_t.stagedUncommittedSha,Ot.uncommittedSha=_t.uncommittedSha,function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(Bt||(Bt={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:current-branch",e.CurrentBranchWithTracking="gitlens:current-branch:tracking",e.RemoteBranch="gitlens:remote-branch",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:commit-file",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:comparison-results",e.FileHistory="gitlens:file-history",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.SearchResults="gitlens:search-results",e.Stash="gitlens:stash",e.StashFile="gitlens:stash-file",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:status-file",e.StatusFiles="gitlens:status-files",e.StatusFileCommits="gitlens:status-file-commits",e.StatusUpstream="gitlens:status-upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(Nt||(Nt={}));class Lt extends O.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class It extends Lt{get repoPath(){return this.uri.repoPath}}class Wt extends Lt{constructor(e){super(new Te),this.message=e}getChildren(){return[]}getTreeItem(){const e=new O.TreeItem(this.message,O.TreeItemCollapsibleState.None);return e.contextValue=Nt.Message,e}}class Mt extends Lt{constructor(e,t,i){super(new Te),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new O.TreeItem(this.message,O.TreeItemCollapsibleState.None);return e.contextValue=Nt.Pager,e.command=this.getCommand(),e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:Wo.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class Ht extends Mt{constructor(e,t,i){super(`${e} ${Q.Space}${Q.Dash}${Q.Space} this may take a while`,t,i),this.args={maxCount:0}}}class jt extends Lt{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.branchFolderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of s.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new jt(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new O.TreeItem(this.label,O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Folder,e.resourceUri=this.explorer.folderResourceUri,e}get label(){return this.branchFolderName}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(At||(At={}));class Gt extends Lt{constructor(e,t,i,s){super(Te.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await Wo.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new O.TreeItem(this.label,O.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,(this.displayAs&At.CommitIcon)===At.CommitIcon)e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark","icon-commit.svg")),light:Wo.context.asAbsolutePath(Se.join("images","light","icon-commit.svg"))};else if((this.displayAs&At.StatusIcon)===At.StatusIcon){const t=tt(this.status.status);e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark",t)),light:Wo.context.asAbsolutePath(Se.join("images","light",t))}}else(this.displayAs&At.Gravatar)===At.Gravatar&&(e.iconPath=this.commit.getGravatarUri(Wo.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Se.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&At.CommitLabel?Rt.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dataFormat:Wo.config.defaultDateFormat}):Tt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get resourceType(){return Nt.CommitFile}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:Ut.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Vt extends Lt{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(Vt.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==F.List){e=[];for(const t of s.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new Vt(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof Vt?-1:1)-(t instanceof Vt?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new O.TreeItem(this.label,O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Folder,e.resourceUri=this.explorer.folderResourceUri,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||F.Auto;if(s===F.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return F.List}return F.Tree}return s}}class Qt extends It{constructor(e,t,i){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...f.map(e.fileStatuses,t=>new Gt(t,e.toFileCommit(t),this.explorer,At.File))];if(this.explorer.config.files.layout!==F.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>y.normalizePath(Se.join(...e)),this.explorer.config.files.compact),i=new Vt(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){const e=new O.TreeItem(Rt.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:Wo.config.defaultDateFormat}),O.TreeItemCollapsibleState.Collapsed);return e.contextValue=void 0===this.branch||this.branch.current?Nt.CommitOnCurrentBranch:Nt.Commit,this.explorer.config.avatars?e.iconPath=this.commit.getGravatarUri(Wo.config.defaultGravatarsStyle):e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-commit.svg"),light:Wo.context.asAbsolutePath("images/light/icon-commit.svg")},e}getCommand(){return{title:"Compare File with Previous Revision",command:Ut.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Kt extends It{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===_.List?e:Oe.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await Wo.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new Wt("No commits yet")];const t=[...f.map(e.commits.values(),e=>new Qt(e,this.explorer,this.branch))];return e.truncated&&t.push(new Ht("Show All Commits",this,this.explorer)),t}async getTreeItem(){let e=this.label;!this.branch.remote&&void 0!==this.branch.tracking&&this.explorer.config.showTrackingBranch&&(e+=` ${Q.Space}${Q.ArrowLeftRight}${Q.Space} ${this.branch.tracking}`);const t=new O.TreeItem(`${this.branch.current?`${Q.Check} ${Q.Space}`:""}${e}`,O.TreeItemCollapsibleState.Collapsed);this.branch.remote?t.contextValue=Nt.RemoteBranch:this.branch.current?t.contextValue=this.branch.tracking?Nt.CurrentBranchWithTracking:Nt.CurrentBranch:t.contextValue=this.branch.tracking?Nt.BranchWithTracking:Nt.Branch;let i="";return this.branch.tracking&&(this.branch.state.ahead&&this.branch.state.behind?i="-yellow":this.branch.state.ahead?i="-green":this.branch.state.behind&&(i="-red")),t.iconPath={dark:Wo.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:Wo.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},t}}class zt extends Lt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...f.filterMap(e,e=>e.remote?void 0:new Kt(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===_.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),r=new jt(this.repo.path,"",void 0,s,this.explorer),a=await r.getChildren();return void 0!==i&&a.splice(0,0,i),a}async getTreeItem(){const e=new O.TreeItem("Branches",this.active?O.TreeItemCollapsibleState.Expanded:O.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Nt.BranchesWithRemotes:Nt.Branches,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-branch.svg"),light:Wo.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class qt extends Lt{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...f.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new Kt(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===_.List)return t;const i=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new jt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ge.Fetch),t=this.remote.types.find(e=>e.type===Ge.Push);let i;i=e&&t?Q.ArrowLeftRight:e?Q.ArrowLeft:t?Q.ArrowRight:Q.Dash;const s=`${this.remote.name} ${Q.Space}${i}${Q.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${Q.Space}${Q.Dot}${Q.Space} ${this.remote.path}`,o=new O.TreeItem(s,O.TreeItemCollapsibleState.Collapsed);return o.contextValue=Nt.Remote,o}}class Yt extends Lt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new Wt("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...f.map(e,e=>new qt(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new O.TreeItem("Remotes",O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Remotes,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-remote.svg"),light:Wo.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class Xt extends Lt{constructor(e,t,i,s){super(Te.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new Gt(this.status,e,this.explorer,At.CommitLabel|(this.explorer.config.avatars?At.Gravatar:At.CommitIcon)))}async getTreeItem(){const e=new O.TreeItem(this.label,O.TreeItemCollapsibleState.Collapsed);e.contextValue=Nt.StatusFileCommits;const t=tt(this.status.status);return e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark",t)),light:Wo.context.asAbsolutePath(Se.join("images","light",t))},1===this.commits.length&&this.commits[0].isUncommitted&&(e.collapsibleState=O.TreeItemCollapsibleState.None,e.contextValue=Nt.StatusFile,e.command=this.getCommand()),this._label=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Se.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Tt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getCommand(){return{title:"Compare File with Previous Revision",command:Ut.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Jt extends Lt{constructor(e,t,i){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.supportsPaging=!0,this.repoPath=e.repoPath}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await Wo.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(f.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...f.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Ot.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,Ot.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Ot.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Ot.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Ot.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const r=o.groupBy(e,e=>e.fileName);let a=[...f.map(s.values(r),e=>new Xt(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==F.List){const e=o.makeHierarchical(a,e=>e.uri.getRelativePath().split("/"),(...e)=>y.normalizePath(Se.join(...e)),this.explorer.config.files.compact),i=new Vt(t,"",void 0,e,this.explorer);a=await i.getChildren()}else a.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&a.push(new Ht("Show All Changes",this,this.explorer)),a}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await Wo.git.getChangedFilesCount(this.repoPath,`${this.status.upstream}...`);void 0!==t&&(e+=t.files)}const t=`${e} file${e>1?"s":""} changed`,i=new O.TreeItem(t,O.TreeItemCollapsibleState.Collapsed);return i.contextValue=Nt.StatusFiles,i.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-diff.svg"),light:Wo.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class Zt extends Lt{constructor(e,t,i){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await Wo.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...f.map(t.commits.values(),e=>new Qt(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await Wo.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=f.first(t.commits.values())),[...f.map(i,e=>new Qt(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} commit${this.status.state.ahead>1?"s":""} (ahead of ${this.status.upstream})`:`${this.status.state.behind} commit${this.status.state.behind>1?"s":""} (behind ${this.status.upstream})`,t=new O.TreeItem(e,O.TreeItemCollapsibleState.Collapsed);return t.contextValue=Nt.StatusUpstream,t.iconPath={dark:Wo.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:Wo.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class ei extends Lt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new Zt(e,"behind",this.explorer)),e.state.ahead&&this.children.push(new Zt(e,"ahead",this.explorer)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new Jt(e,t,this.explorer))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new O.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=O.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o="",r="";e.upstream?e.state.ahead||e.state.behind?(o=`${e.branch}${i?" has uncommitted changes and":""} is not up-to-date with ${e.upstream}`,t=!0,e.state.ahead&&e.state.behind?r="-yellow":e.state.ahead?r="-green":e.state.behind&&(r="-red")):o=`${e.branch}${i?" has uncommitted changes and":""} is up-to-date with ${e.upstream}`:o=`${e.branch} ${i?"has uncommitted changes":this.includeWorkingTree?"has no changes":"has nothing to commit"}`,s=t||i?this.active?O.TreeItemCollapsibleState.Expanded:O.TreeItemCollapsibleState.Collapsed:O.TreeItemCollapsibleState.None;const a=new O.TreeItem(o,s);return a.contextValue=Nt.Status,a.iconPath={dark:Wo.context.asAbsolutePath(`images/dark/icon-repo${r}.svg`),light:Wo.context.asAbsolutePath(`images/light/icon-repo${r}.svg`)},a}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class ti extends Gt{constructor(e,t,i){super(e,t,i,At.File)}get resourceType(){return Nt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class ii extends It{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await Wo.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=f.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new ti(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new O.TreeItem(Rt.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:Wo.config.defaultDateFormat}),O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Stash,e}}class si extends Lt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new Wt("No stashed changes")]:[...f.map(e.commits.values(),e=>new ii(e,this.explorer))]}getTreeItem(){const e=new O.TreeItem("Stashes",O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Stashes,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-stash.svg"),light:Wo.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class oi extends It{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get ref(){return this.tag.name}async getChildren(){const e=await Wo.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new Wt("No commits yet")];const t=[...f.map(e.commits.values(),e=>new Qt(e,this.explorer))];return e.truncated&&t.push(new Ht("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new O.TreeItem(this.tag.name,O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Tag,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-tag.svg"),light:Wo.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class ri extends Lt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getTags();return 0===e.length?[new Wt("No tags yet")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...e.map(e=>new oi(e,this.uri,this.explorer))])}async getTreeItem(){const e=new O.TreeItem("Tags",O.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Tags,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-tag.svg"),light:Wo.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class ai extends Lt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}async getChildren(){return this.resetChildren(),this.updateSubscription(),this.children=[new ei(this.uri,this.repo,this.explorer,this.active),new zt(this.uri,this.repo,this.explorer,this.active),new Yt(this.uri,this.repo,this.explorer),new si(this.uri,this.repo,this.explorer),new ri(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${y.pad(Q.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new O.TreeItem(e,this.active?O.TreeItemCollapsibleState.Expanded:O.TreeItemCollapsibleState.Collapsed);return t.contextValue=Nt.Repository,t}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||O.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(re.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(Ve.Repository)||e.changed(Ve.Config))this.explorer.refreshNode(this);else{if(e.changed(Ve.Stashes)){const e=this.children.find(e=>e instanceof si);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(Ve.Remotes)){const e=this.children.find(e=>e instanceof Yt);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(Ve.Tags)){const e=this.children.find(e=>e instanceof ri);void 0!==e&&this.explorer.refreshNode(e)}}}}class ni extends Lt{constructor(e){super(void 0),this.explorer=e,Wo.context.subscriptions.push(O.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(O.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}async onActiveEditorChanged(e){if(void 0!==e&&!X(e))return;let t=!1;try{const i=await Wo.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await Wo.git.getRepository(i);if(void 0===s)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new ai(Te.fromRepoPath(s.path),s,this.explorer,!0)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){return void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new O.TreeItem("No active repository",O.TreeItemCollapsibleState.None)}}class hi extends Lt{constructor(e,t,i=Nt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new Qt(this.commit,this.explorer).getChildren();return e.splice(0,0,new Wt(Rt.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!1}))),e}async getTreeItem(){const e=Rt.fromTemplate(`Commit \${sha} ${y.pad(Q.Dash,1,1)} \${authorAgo}`,this.commit,Wo.config.defaultDateFormat),t=new O.TreeItem(e,O.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class ci extends Lt{constructor(e,t,i,s,o=Nt.Results){super(Te.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...f.map(e.commits.values(),e=>new Qt(e,this.explorer))];return e.truncated&&t.push(new Ht("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new O.TreeItem(await this.getLabel(),e&&e.count>0?O.TreeItemCollapsibleState.Expanded:O.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class li extends Lt{constructor(e,t,i,s,o){super(Te.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new O.TreeItem(this.label,O.TreeItemCollapsibleState.None);e.contextValue=Nt.StatusFile;const t=tt(this.status.status);return e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark",t)),light:Wo.context.asAbsolutePath(Se.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=Se.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Tt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:Ut.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Te.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class di extends Lt{constructor(e,t,i,s,o,r){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.labelFn=s,this.diffFn=o,this.explorer=r,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...f.map(e,e=>new li(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==F.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>y.normalizePath(Se.join(...e)),this.explorer.config.files.compact),i=new Vt(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new O.TreeItem(await this.getLabel(),e&&e.length>0?O.TreeItemCollapsibleState.Expanded:O.TreeItemCollapsibleState.None);return t.contextValue=Nt.Results,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.diffFn();this._cache={label:this.labelFn(e),diff:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getDiff(){return(await this.ensureCache()).diff}}class mi extends Lt{constructor(e,t,i,s){super(Te.fromRepoPath(e)),this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){this.resetChildren();return this.children=[new ci(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>Wo.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1}...${this.ref2||"HEAD"}`}),this.explorer),new di(this.uri.repoPath,this.ref1,this.ref2,e=>{const t=void 0!==e?e.length:0;return 1===t?"1 file changed":`${0===t?"No":t} files changed`},()=>Wo.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),this.explorer)],this.children}async getTreeItem(){let e="";if(await Wo.git.getRepositoryCount()>1){const t=await Wo.git.getRepository(this.uri.repoPath);e=` ${y.pad(Q.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new O.TreeItem(`Comparing ${Ot.shortenSha(this.ref1)} to ${""!==this.ref2?Ot.shortenSha(this.ref2):"Working Tree"}${e}`,O.TreeItemCollapsibleState.Expanded);return t.contextValue=Nt.ComparisonResults,t}}class ui extends Lt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=At.CommitLabel|(this.explorer.config.avatars?At.Gravatar:At.StatusIcon),i=await Wo.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=Ot.uncommittedSha,void 0!==i.indexStatus?o=Ot.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=Ot.stagedUncommittedSha,o="HEAD");const r=new je(Be.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new Gt(i,r,this.explorer,t))}const s=await Wo.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...f.map(s.commits.values(),e=>new Gt(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new Wt("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new O.TreeItem(`${this.uri.getFormattedPath()}`,O.TreeItemCollapsibleState.Expanded);return e.contextValue=Nt.FileHistory,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-history.svg"),light:Wo.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||O.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){e.changed(Ve.Repository)&&(re.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class gi extends Lt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new ui(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new O.TreeItem(`${this.uri.getFormattedPath()}`,O.TreeItemCollapsibleState.Expanded);return e.contextValue=Nt.History,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-history.svg"),light:Wo.context.asAbsolutePath("images/light/icon-history.svg")},e}}class pi extends Lt{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return this.resetChildren(),this.children=this.repositories.sort((e,t)=>e.index-t.index).map(e=>new ai(Te.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new ni(this.explorer)),this.children}getTreeItem(){const e=new O.TreeItem("Repositories",O.TreeItemCollapsibleState.Expanded);return e.contextValue=Nt.Repositories,e}}function fi(e,t){return e instanceof O.Uri?e:void 0!==t&&void 0!==t.document?t.document.uri:void 0}function vi(e){return"view"===e.type&&e.node.branch&&e.node.branch instanceof Oe}function wi(e){return"view"===e.type&&e.node.commit&&e.node.commit instanceof Ae}function Ci(e){return"view"===e.type&&e.node.remote&&e.node.remote instanceof Ke}function bi(e){return void 0!==e&&(void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates))}function yi(e){return void 0!==e&&void 0!==e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowFileBlame="gitlens.showFileBlame",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowLineBlame="gitlens.showLineBlame",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame"}(Ut||(Ut={}));class xi extends O.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=O.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>O.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=O.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=xi.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(void 0===o||function(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(void 0===o||o instanceof O.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof Lt){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(yi(o)){const t=[];let s=0;for(const e of i){if(!yi(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(bi(o)){const t=[];let s=0;for(const e of i){if(!bi(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class Si extends xi{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,O.window.activeTextEditor,...t)}}let $i=void 0;class Di extends Si{constructor(e){super(e)}_execute(e,...t){return $i={command:e,args:t},super._execute(e,...t)}}class ki extends O.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(O.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=O.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Pi(e,t={}){const{rethrow:i}=t,s=m.__rest(t,["rethrow"]);try{e instanceof Te&&(e=e.fileUri({noSha:!0}));const t=await O.workspace.openTextDocument(e);return O.window.showTextDocument(t,Object.assign({preserveFocus:!1,preview:!0,viewColumn:O.ViewColumn.Active},s))}catch(e){if(i)throw e;return void re.error(e,"openEditor")}}class _i extends ki{constructor(){super([Ut.ClearFileAnnotations,Ut.ComputingFileAnnotations])}async execute(e,t,i){if(void 0!==e){if(void 0!==i&&!te.equals(i,e.document.uri)){const t=O.window.visibleTextEditors.find(e=>te.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return Wo.annotations.clear(e)}catch(e){return re.error(e,"ClearFileAnnotationsCommand"),O.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class Fi extends O.Disposable{constructor(){super(()=>this.dispose());const e=p.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=O.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return O.commands.executeCommand(j.CloseActiveEditor)}async next(){return O.commands.executeCommand(j.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=0,t(e))}),s=setTimeout(()=>{t(O.window.activeTextEditor),s=0},e)});return this._resolver=void 0,t}}var Ri;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ResultsExplorerNotice="suppressResultsExplorerNotice"}(Ri||(Ri={}));class Ti{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Ti.showMessage("info","Commit has no previous commit",Ri.CommitHasNoPreviousCommitWarning):Ti.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit`,Ri.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Ti.showMessage("warn",`${e}. The commit could not be found`,Ri.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Ti.showMessage("warn",`${e}. The file is probably not under source control`,Ri.FileNotUnderSourceControlWarning)}static showLineUncommittedWarningMessage(e){return Ti.showMessage("warn",`${e}. The line has uncommitted changes`,Ri.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Ti.showMessage("warn",`${e}. No repository could be found`,Ri.NoRepositoryWarning)}static showResultExplorerInfoMessage(){return Ti.showMessage("info",'If you can\'t find your results, click on "GITLENS RESULTS" at the bottom of the Explorer view',Ri.ResultsExplorerNotice,null)}static showUnsupportedGitVersionErrorMessage(e){return Ti.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git`,Ri.GitVersionWarning)}static async showMessage(e,t,i,s="Don't Show Again",...o){if(re.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),jo.get(jo.name("advanced")("messages")(i).value))return void re.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let r=void 0;switch(e){case"info":r=await O.window.showInformationMessage(t,...o);break;case"warn":r=await O.window.showWarningMessage(t,...o);break;case"error":r=await O.window.showErrorMessage(t,...o)}if(null===s||r===s){re.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`);const o=jo.name("advanced")("messages").value,a=jo.get(o);if(a[i]=!0,await jo.update(o,a,O.ConfigurationTarget.Global),r===s)return}return re.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${r}`),r}}class Ei extends Si{constructor(){super(Ut.CloseUnchangedFiles)}async execute(e,t,i={}){t=fi(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to close unchanged files");const s=await Wo.git.getStatusForRepo(e);if(void 0===s)return O.window.showWarningMessage("Unable to close unchanged files");i.uris=s.files.map(e=>e.uri)}if(0===i.uris.length)return O.commands.executeCommand(j.CloseAllEditors);const e=new Fi;let s=0,o=void 0,r=O.window.activeTextEditor;for(;;){if(void 0!==r){if(ee.equals(o,r,{useId:!0,usePosition:!0}))break;if(void 0!==r.document&&(r.document.isDirty||i.uris.some(e=>te.equals(e,r.document&&r.document.uri)))){const t=o;if(o=r,r=await e.awaitNext(500),ee.equals(t,r,{useId:!0,usePosition:!0}))break;continue}}if(o=r,r=await e.awaitClose(500),void 0===o&&void 0===r){if(++s>=4)break}else s=0}return void e.dispose()}catch(e){return re.error(e,"CloseUnchangedFilesCommand"),O.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Bi extends Si{constructor(){super(Ut.CopyMessageToClipboard)}async preExecute(e,t={}){return wi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=fi(t,e);const o=await new Promise(function(e){e()}).then(i.bind(null,13));try{if(s=Object.assign({},s),void 0===t){const t=await Wo.git.getActiveRepoPath(e);if(!t)return;const i=await Wo.git.getLog(t,{maxCount:1});if(!i)return;return s.message=f.first(i.commits.values()).message,void o.copy(s.message)}const i=await Te.fromUri(t);if(void 0===s.message){if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(i,t,e.document.getText()):await Wo.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return re.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),O.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const t=await Wo.git.getLogCommit(i.repoPath,s.sha);if(void 0===t)return;s.message=t.message}return void o.copy(s.message,e=>{if(e){if(e.message.includes("xclip"))return void O.window.showErrorMessage("Unable to copy message, xclip is not installed. You can install it via `sudo apt-get install xclip`");re.error(e,"CopyMessageToClipboardCommand"),O.window.showErrorMessage("Unable to copy message. See output channel for more details")}})}catch(e){return re.error(e,"CopyMessageToClipboardCommand"),O.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class Ni extends Si{constructor(){super(Ut.CopyShaToClipboard)}async preExecute(e,t={}){return wi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=fi(t,e);const o=await new Promise(function(e){e()}).then(i.bind(null,13));try{if(s=Object.assign({},s),void 0===t){const t=await Wo.git.getActiveRepoPath(e);if(!t)return;const i=await Wo.git.getLog(t,{maxCount:1});if(!i)return;return s.sha=f.first(i.commits.values()).sha,void o.copy(s.sha)}const i=await Te.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(i,t,e.document.getText()):await Wo.git.getBlameForLine(i,t);if(void 0===o)return;s.sha=o.commit.sha}catch(e){return re.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${t})`),O.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.copy(s.sha,e=>{if(e){if(e.message.includes("xclip"))return void O.window.showErrorMessage("Unable to copy commit id, xclip is not installed. You can install it via `sudo apt-get install xclip`");re.error(e,"CopyShaToClipboardCommand"),O.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}})}catch(e){return re.error(e,"CopyShaToClipboardCommand"),O.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}const Ai=Object.create(null),Ui=["left","right",",",".","escape"],Oi=[];class Li extends O.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||Ai}async dispose(){const e=Oi.indexOf(this.mapping);re.log("KeyboardScope.dispose",Oi.length,e),e===Oi.length-1?(Oi.pop(),await this.updateKeyCommandsContext(Oi[Oi.length-1])):Oi.splice(e,1)}async begin(){return Oi.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=Oi[Oi.length-1];t===this.mapping&&t[e]&&(re.log("KeyboardScope.clearKeyCommand",Oi.length,e),t[e]=void 0,await q(`${G.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=Oi[Oi.length-1];i===this.mapping&&(re.log("KeyboardScope.setKeyCommand",Oi.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await q(`${G.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Ui)t.push(q(`${G.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class Ii extends O.Disposable{constructor(){super(()=>this.dispose());const e=Ui.map(e=>O.commands.registerCommand(`${L}.key.${e}`,()=>this.execute(e),this));this._disposable=O.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return re.log("Keyboard.beginScope",Oi.length),await new Li(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(Oi.length)try{let t=Oi[Oi.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return re.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void re.error(e,"Keyboard.execute")}}}class Wi{constructor(e){this.branchOrTag=e,e instanceof Oe?(this.label=`${e.current?`$(check)${Q.Space}`:Q.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${Q.Space.repeat(2)} remote branch`:""):(this.label=`${Q.Space.repeat(4)} ${e.name}`,this.description=`${Q.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Oe&&this.branchOrTag.remote}}class Mi{static showProgress(e){return ji(e,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new Wi(e)),...t.map(e=>new Wi(e)),...e.filter(e=>e.remote).map(e=>new Wi(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await Wo.keyboard.beginScope({left:s.goBackCommand||Ai});s.progressCancellation&&s.progressCancellation.cancel();const a=await O.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:Hi()});return await r.dispose(),a}}function Hi(){return!jo.get(jo.name("advanced")("quickPick")("closeOnFocusOut").value)}function ji(e,t){const i=new O.CancellationTokenSource;return async function(e,t,i){const s=i&&await Wo.keyboard.beginScope(i);try{await O.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Hi()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class Gi{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):O.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class Vi extends Gi{constructor(e){super({label:e,description:""})}}class Qi extends Gi{constructor(e,t){super({label:"",description:""},e,t)}}class Ki extends Gi{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Pi(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class zi extends Gi{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Pi(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class qi{constructor(e){this.commit=e;let t=e.message;const i=t.indexOf("\n");-1!==i&&(t=`${t.substring(0,i)}${Q.Space}$(ellipsis)`),e.isStash?(this.label=t,this.description="",this.detail=`${Q.Space} ${e.stashName||e.shortSha} ${y.pad(Q.Dot,1,1)} ${e.formattedDate} ${y.pad(Q.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${y.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${Q.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${y.pad(Q.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class Yi extends Gi{constructor(e,t={label:"Show in Results",description:`${y.pad(Q.Dash,2,2)} displays commit in the GitLens Results view`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){Wo.resultsExplorer.showCommitInResults(this.commit)}}class Xi extends Gi{constructor(e,t,i={label:"Show in Results",description:`${y.pad(Q.Dash,2,2)} displays commits in the GitLens Results view`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){Wo.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class Ji extends Xi{constructor(e,t,i={label:"Show in Results",description:`${y.pad(Q.Dash,2,2)} displays results in the GitLens Results view`}){super(e,{label:t},i),this.results=e,this.search=t}}class Zi extends Gi{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${y.pad(Q.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Mi.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([Wo.git.getBranches(this.repoPath),Wo.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Mi.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.dispose()}}}class es{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${Q.Space}`:Q.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${Q.Space.repeat(2)} remote branch`:""}}class ts{static async show(e,t,i={}){const s=e.map(e=>new es(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await O.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:Hi()})}}class is extends Gi{constructor(e,t){super({label:`$(link-external) Open ${me(t)} in ${e.provider.name}`,description:`${y.pad(Q.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class ss extends Gi{constructor(e,t,i){const s=me(t);let o="";switch(t.type){case de.Branch:o=`$(git-branch) ${t.branch}`;break;case de.Branches:o="$(git-branch) Branches";break;case de.Commit:o=`$(git-commit) ${Ot.shortenSha(t.sha)}`;break;case de.File:o=`$(file-text) ${Se.basename(t.fileName)}`;break;case de.Repo:o="$(repo) Repository";break;case de.Revision:if(void 0!==t.commit&&t.commit instanceof je)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${Se.basename(t.fileName)} in ${Q.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${Q.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${Se.basename(t.fileName)} in ${Q.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":Ot.shortenSha(t.sha);o=`$(file-text) ${Se.basename(t.fileName)}${e?` in ${Q.Space}$(git-commit) ${e}`:""}`}}const r=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===r.provider.name)?r.provider.name:"Remote"}${Q.Ellipsis}`,description:`${y.pad(Q.Dash,2,3)} ${o}`},Ut.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${r.provider.name}`,description:`${y.pad(Q.Dash,2,3)} $(repo) ${r.provider.path} ${y.pad(Q.Dot,1,1)} ${o}`},Ut.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class os{static async show(e,t,i,s){const o=e.map(e=>new is(e,i));s&&o.splice(0,0,s);const r=await O.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Hi()});if(void 0!==r)return r}}class rs extends Ki{constructor(e,t){const i=Ze(t.status),s=Xe.getFormattedDirectory(t,!0);super(Te.toRevisionUri(e.sha,t,e.repoPath),{label:`${y.pad(i,4,2)} ${Se.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):O.commands.executeCommand(Ut.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class as extends zi{constructor(e,t=!1,i){const s=e.repoPath;super(o.filterMap(e.fileStatuses,e=>Te.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class ns extends zi{constructor(e,t){super(o.filterMap(e.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${y.pad(Q.Dash,2,3)} in ${Q.Space}$(git-commit) ${e.shortSha}`})}}class hs{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new rs(e,t)),a=e.isStash;let n=0;if(a)r.splice(n++,0,new Gi({label:"$(git-pull-request) Apply Stashed Changes",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Gi({label:"$(x) Delete Stashed Changes",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Yi(e));else{r.splice(n++,0,new Yi(e));const t=(await Wo.git.getRemotes(e.repoPath)).filter(e=>void 0!==e.provider);t.length&&r.splice(n++,0,new ss(t,{type:"commit",sha:e.sha},s))}r.splice(n++,0,new as(e)),r.splice(n++,0,new ns(e)),r.splice(n++,0,new Gi({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${Q.Space} $(git-compare) ${Q.Space} $(git-commit) ${e.shortSha}`},Ut.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(n++,0,new Gi({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.shortSha} ${Q.Space} $(git-compare) ${Q.Space} $(file-directory) Working Tree`},Ut.DiffDirectory,[t,{ref1:e.sha}])),a||r.splice(n++,0,new Gi({label:"$(clippy) Copy Commit ID to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.shortSha}`},Ut.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(n++,0,new Gi({label:"$(clippy) Copy Commit Message to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(n++,0,new Gi({label:"Changed Files",description:e.getDiffStatus()},Ut.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let h=void 0,c=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await Wo.git.getLog(e.repoPath,{maxCount:Wo.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?Ai:new Qi(Ut.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await Wo.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&f.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?Ai:new Qi(Ut.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new Qi(Ut.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new Qi(Ut.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await Wo.keyboard.beginScope({left:i,",":h,".":c}),d=await O.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${y.pad(Q.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${y.pad(Q.Dot,1,1)} ${e.message}`,ignoreFocusOut:Hi(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class cs extends Gi{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${y.pad(Q.Dash,2,3)} $(file-text) ${Se.basename(e.fileName)} in ${Q.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await Wo.git.checkoutFile(e),Pi(e,{preserveFocus:!0,preview:!1})}}class ls extends Ki{constructor(e,t){super(O.Uri.file(Se.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${y.pad(Q.Dash,2,3)} ${Se.basename(e.fileName)}`})}}class ds extends Ki{constructor(e,t){let i,s;"D"===e.status?(s=Te.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${y.pad(Q.Dash,2,3)} ${Se.basename(e.fileName)} in ${Q.Space}$(git-commit) ${e.previousShortSha} (deleted in ${Q.Space}$(git-commit) ${e.shortSha})`):(s=Te.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${y.pad(Q.Dash,2,3)} ${Se.basename(e.fileName)} in ${Q.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class ms{static async show(e,t,i,s,o){const r=[],a=e.isStash,n=e.workingFileName&&Se.basename(e.workingFileName)||Se.basename(e.fileName),h=e.isUncommitted;if(h){const t=await Wo.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),a&&r.push(new cs(e)),e.previousFileShortSha&&r.push(new Gi({label:"$(git-compare) Open Changes",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${Q.Space} $(git-compare) ${Q.Space} $(git-commit) ${e.shortSha}`},Ut.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new Gi({label:"$(git-compare) Open Changes with Working Tree",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.shortSha} ${Q.Space} $(git-compare) ${Q.Space} $(file-text) ${n}`},Ut.DiffWithWorking,[O.Uri.file(Se.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new ls(e)),r.push(new ds(e));const c=(await Wo.git.getRemotes(e.repoPath)).filter(e=>void 0!==e.provider);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await Wo.git.getBranch(e.repoPath);r.push(new ss(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}a||r.push(new ss(c,{type:"revision",fileName:e.fileName,commit:e},s))}a||(r.push(new cs(e)),r.push(new Gi({label:"$(clippy) Copy Commit ID to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.shortSha}`},Ut.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new Gi({label:"$(clippy) Copy Commit Message to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new Gi({label:"$(history) Show File History",description:`${y.pad(Q.Dash,2,3)} of ${Se.basename(e.fileName)}`},Ut.ShowQuickFileHistory,[O.Uri.file(Se.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),a||(r.push(new Gi({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${y.pad(Q.Dash,2,3)} of ${Se.basename(e.fileName)} ${y.pad(Q.Dot,1,1)} from ${Q.Space}$(git-commit) ${e.shortSha}`},Ut.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),r.push(new Gi({label:"$(git-commit) Show Commit Details",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.shortSha}`},Ut.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&r.splice(0,0,i);let l=void 0,d=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.previousSha){if(void 0===(s=await Wo.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:Wo.config.advanced.maxListItems,ref:e.sha,renames:!0})))return Ai;void 0===(r=s&&s.commits.get(e.sha))&&e.isMerge&&(r=f.first(s.commits.values())),r&&(r.nextSha=e.nextSha,r.nextFileName=e.nextFileName)}return void 0===r||void 0===r.previousSha?Ai:new Qi(Ut.ShowQuickCommitFileDetails,[r.previousUri,{fileLog:s,sha:r.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.nextSha){s=void 0,r=void 0;const i=await Wo.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((r=e).nextSha=i.sha,r.nextFileName=i.originalFileName||i.fileName)}return void 0===r||void 0===r.nextSha?Ai:new Qi(Ut.ShowQuickCommitFileDetails,[r.nextUri,{fileLog:s,sha:r.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new Qi(Ut.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new Qi(Ut.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const m=await Wo.keyboard.beginScope({left:i,",":l,".":d}),u=await O.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${y.pad(Q.Dot,1,1)} ${h?`Uncommitted ${Q.ArrowRightHollow} `:""}${e.shortSha} ${y.pad(Q.Dot,1,1)} ${e.author}, ${e.formattedDate} ${y.pad(Q.Dot,1,1)} ${e.message}`,ignoreFocusOut:Hi(),onDidSelectItem:e=>{m.setKeyCommand("right",e)}});return await m.dispose(),u}}class us{static showProgress(e){return ji(e,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s){const o=e&&[...f.map(e.commits.values(),e=>new qi(e))]||[new Vi("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const r=await Wo.keyboard.beginScope({left:s.goBackCommand});i.cancel();const a=await O.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Hi()});return await r.dispose(),a}}class gs{static showProgress(e){return ji(`${e} history ${Q.Dash} search by commit message, filename, or commit id`,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s,o,r){const a=Array.from(f.map(e.commits.values(),e=>new qi(e))),n=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to ${Q.Space}$(git-branch) ${i} history`},Ut.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=(await Wo.git.getRemotes(t&&t.repoPath||e.repoPath)).filter(e=>void 0!==e.provider);h.length&&a.splice(0,0,new ss(h,{type:"branch",branch:i},n)),a.splice(0,0,new Gi({label:"$(search) Show Commit Search",description:`${y.pad(Q.Dash,2,3)} search for commits by message, author, files, or commit id`},Ut.ShowCommitSearch,[Te.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&a.splice(0,0,new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),r&&a.splice(0,0,r),e.truncated)){const s=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} newer commits`},Ut.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),n=f.last(e.commits.values());null!=n&&(c=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} older commits`},Ut.ShowQuickBranchHistory,[new Te(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),a.splice(0,0,c))}if(o&&a.splice(0,0,o),s.token.isCancellationRequested)return;const l=await Wo.keyboard.beginScope({left:o,",":c,".":r});s.cancel();const d=await O.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${Q.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Hi()});return await l.dispose(),d}}class ps{static showProgress(e){return ji(e,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(f.map(e.commits.values(),e=>new qi(e)));let r=0;if(s.pickerOnly&&(r++,o.splice(0,0,new Zi(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(r++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)r++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await Wo.git.findWorkingFileName(Se.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,o.splice(0,0,new Gi({label:"$(history) Show File History",description:`${y.pad(Q.Dash,2,3)} of ${Se.basename(i)}`},Ut.ShowQuickFileHistory,[O.Uri.file(Se.resolve(e.repoPath,i)),{goBackCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${Se.basename(t.fsPath)}${t.sha?` from ${Q.Space}$(git-commit) ${t.shortSha}`:""}`},Ut.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(r++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(r++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await Wo.git.getBranch(t.repoPath),a=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${Se.basename(t.fsPath)}${t.sha?` from ${Q.Space}$(git-commit) ${t.shortSha}`:""}`},Ut.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(r++,0,new Gi({label:"$(history) Show Branch History",description:`${y.pad(Q.Dash,2,3)} shows  ${Q.Space}$(git-branch) ${i.name} history`},Ut.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:a}]));const n=(await Wo.git.getRemotes(t.repoPath)).filter(e=>void 0!==e.provider);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(r++,0,new ss(n,e,a))}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await Wo.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await O.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Hi()});return await a.dispose(),n}}class fs{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class vs{static async show(e,t){const i=[...f.map(await Wo.git.getRepositories(),e=>new fs(e))];return void 0!==t&&i.splice(0,0,t),await O.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Hi()})}}class ws extends Ki{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":Q.Space.repeat(3)}${y.pad(s,2,2)} ${Se.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new je(Be.File,e.repoPath,Ot.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new je(Be.File,e.repoPath,Ot.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?Ot.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return O.commands.executeCommand(Ut.DiffWithPrevious,Te.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class Cs extends Gi{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},Ut.OpenChangedFiles,[void 0,{uris:i}])}}class bs{static computeStatus(e){let t=0,i=0,s=0,o=0,r=0,a=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":r++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":a++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+r,l=i+o+a;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${r}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${a}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...f.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new ws(e.with({indexStatus:null}),e.indexStatus),new ws(e.with({workTreeStatus:null}))]:[new ws(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to ${Q.Space}$(git-branch) ${e.branch} status`},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const r=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;r>-1&&(i.splice(r,0,new Gi({label:"Unstaged Files",description:o.unstagedStatus},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(r,0,new Cs(o.stagedAddsAndChanges,{label:`${Q.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new Cs(o.unstagedAddsAndChanges,{label:`${Q.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Gi({label:"Staged Files",description:o.stagedStatus},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Gi({label:"Unstaged Files",description:o.unstagedStatus},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new Cs(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new Gi({label:"$(x) Close Unchanged Files",description:""},Ut.CloseUnchangedFiles))):i.push(new Gi({label:"No changes in the working tree",description:""},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Gi({label:"$(inbox) Show Stashed Changes",description:`${y.pad(Q.Dash,2,3)} shows stashed changes in the repository`},Ut.ShowQuickStashList,[Te.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Gi({label:`$(cloud-upload)${Q.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${Q.Space}$(git-branch) ${e.upstream}`,description:`${y.pad(Q.Dash,2,3)} shows commits in ${Q.Space}$(git-branch) ${e.branch} but not ${Q.Space}$(git-branch) ${e.upstream}`},Ut.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new Gi({label:`$(cloud-download)${Q.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${Q.Space}$(git-branch) ${e.upstream}`,description:`${y.pad(Q.Dash,2,3)} shows commits in ${Q.Space}$(git-branch) ${e.upstream} but not ${Q.Space}$(git-branch) ${e.branch}${e.sha?` (since ${Q.Space}$(git-commit) ${Ot.shortenSha(e.sha)})`:""}`},Ut.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Gi({label:`$(git-branch) ${e.branch} is up-to-date with ${Q.Space}$(git-branch) ${e.upstream}`,description:""},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await Wo.keyboard.beginScope({left:t}),a=await O.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${y.pad(Q.ArrowLeftRight,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Hi(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),a}}class ys{static showProgress(e){return ji("apply"===e?`Apply stashed changes to your working tree${Q.Ellipsis}`:`stashed changes ${Q.Dash} search by message, filename, or commit id`,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s,o){const r=e&&Array.from(f.map(e.commits.values(),e=>new qi(e)))||[];if("list"===t&&r.splice(0,0,new Gi({label:"$(plus) Stash Changes",description:`${y.pad(Q.Dash,2,3)} stashes all changes`},Ut.StashSave,[{goBackCommand:o}])),s&&r.splice(0,0,s),i.token.isCancellationRequested)return;const a=await Wo.keyboard.beginScope({left:s});i.cancel();const n=await O.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${Q.Ellipsis}`:`stashed changes ${Q.Dash} search by message, filename, or commit id`,ignoreFocusOut:Hi()});return await a.dispose(),n}}class xs extends Si{constructor(){super([Ut.DiffDirectory,Ut.ExternalDiffAll,Ut.ExplorersOpenDirectoryDiff,Ut.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case Ut.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case Ut.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof mi&&(t.ref1=e.node.ref1,t.ref2=e.node.ref2);break;case Ut.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof It})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to open directory compare");if(!i.ref1){i=Object.assign({},i);const t=`Compare Working Tree to ${Q.Ellipsis}`;s=Mi.showProgress(t);const[o,r]=await Promise.all([Wo.git.getBranches(e),Wo.git.getTags(e)]);if(s.token.isCancellationRequested)return;const a=await Mi.show(o,r,t,{progressCancellation:s});if(void 0===a)return;if(a instanceof Gi)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void Wo.git.openDirectoryDiff(e,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await O.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return O.commands.executeCommand(j.Open,O.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return re.error(e,"DiffDirectoryCommand"),O.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.dispose()}}}class Ss extends Si{constructor(){super(Ut.DiffLineWithPrevious)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Ot.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(s,t,e.document.getText()):await Wo.git.getBlameForLine(s,t);if(void 0===o)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await Wo.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:Ot.stagedUncommittedSha}))}}catch(e){return re.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Ot.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,o)}}class $s extends Si{constructor(){super(Ut.DiffLineWithWorking)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Ot.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(s,t,e.document.getText()):await Wo.git.getBlameForLine(s,t);if(void 0===o)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await Wo.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?Ot.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return re.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,o)}}class Ds extends Si{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Ae){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:Ot.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(Ut.DiffWith,i)}constructor(){super(Ut.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{Ot.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await Wo.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),Ot.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await Wo.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[e,t]=await Promise.all([Wo.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),Wo.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let s="";void 0===t?s=Ot.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==e&&i.lhs.sha!==Ot.deletedSha||(s="added in ");let o="";if(void 0===e&&""===i.rhs.sha&&(void 0!==t?(o="not in ",s=""):o="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==Ot.deletedSha&&(void 0!==e||""!==o)){const e=Ot.shortenSha(i.lhs.sha)||"";i.lhs.title=`${Se.basename(i.lhs.uri.fsPath)}${""!==e?` (${o}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==Ot.deletedSha){const e=Ot.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${Se.basename(i.rhs.uri.fsPath)}${""!==e?` (${s}${e})`:s}`}const r=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${Q.ArrowLeftRight} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=O.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new O.Range(i.line,0,i.line,0)),await O.commands.executeCommand(j.Diff,void 0===e?Te.toRevisionUri(Ot.deletedSha,i.lhs.uri.fsPath,i.repoPath):O.Uri.file(e),void 0===t?Te.toRevisionUri(Ot.deletedSha,i.rhs.uri.fsPath,i.repoPath):O.Uri.file(t),r,i.showOptions)}catch(e){return re.error(e,"DiffWithCommand","getVersionedFile"),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class ks extends Si{constructor(){super(Ut.DiffWithBranch)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Te.fromUri(t);if(!s.repoPath)return Ti.showNoRepositoryWarningMessage("Unable to open branch compare");const o=`Compare ${Se.basename(s.fsPath)} with ${Q.Ellipsis}`,r=Mi.showProgress(o);try{const[e,t]=await Promise.all([Wo.git.getBranches(s.repoPath),Wo.git.getTags(s.repoPath)]);if(r.token.isCancellationRequested)return;const a=await Mi.show(e,t,o,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===a)return;if(a instanceof Gi)return a.execute();const n=a.name;if(void 0===n)return;let h,c;const l=await Wo.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=y.normalizePath(Se.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=O.Uri.file(Se.join(s.repoPath,t.originalFileName)),c=`${Se.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:a.remote?`remotes/${n}`:n,uri:h||s,title:c||`${Se.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,d)}finally{r.dispose()}}}class Ps extends Si{constructor(){super(Ut.DiffWithNext)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Te.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof je)||void 0!==i.range)try{const e=void 0===i.commit?s.sha:i.commit.sha;if(Ot.isStagedUncommitted(e))return O.commands.executeCommand(Ut.DiffWithWorking,t);const r=await Wo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==e?void 0:2,range:i.range,renames:!0});if(void 0===r)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=e&&r.commits.get(e)||f.first(r.commits.values()),void 0===s.sha&&void 0!==(o=await Wo.git.getStatusForFile(s.repoPath,s.fsPath)))return O.commands.executeCommand(Ut.DiffWithWorking,t)}catch(e){return re.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await Wo.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Ot.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,e)}return O.commands.executeCommand(Ut.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,r)}}class _s extends Si{constructor(){super(Ut.DiffWithPrevious)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Te.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===Ot.deletedSha)return Ti.showCommitHasNoPreviousCommitWarningMessage();let o=!1;Ot.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0);const r=await Wo.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===r)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&r.commits.get(s)||f.first(r.commits.values()),void 0===e.sha){const s=await Wo.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Ot.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:Ot.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,e)}return O.commands.executeCommand(Ut.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return re.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Ot.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,s)}}class Fs extends Si{constructor(){super(Ut.DiffWithRevision)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Te.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${y.pad(Q.Dot,1,1)} ${s.shortSha}`:""} with ${Q.Ellipsis}`,r=ps.showProgress(o);try{const e=await Wo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===e)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let a=void 0;if(e.truncated){const s=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} newer commits`},Ut.DiffWithRevision,[t,Object.assign({},i)]),o=f.last(e.commits.values());null!=o&&(a=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} older commits`},Ut.DiffWithRevision,[new Te(t,o),Object.assign({},i,{nextPageCommand:s})]))}const n=await ps.show(e,s,o,{pickerOnly:!0,progressCancellation:r,currentCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${Q.Space}$(git-commit) ${s.shortSha}`:""}`},Ut.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:a,showAllCommand:void 0!==e&&e.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===n)return;let h;if(n instanceof Zi){const e=await n.execute();if(void 0===e)return;if(e instanceof Gi)return e.execute();h=e.name}else{if(n instanceof Gi)return n.execute();h=n.commit.sha}const c={repoPath:s.repoPath,lhs:{sha:h,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await O.commands.executeCommand(Ut.DiffWith,c)}catch(e){return re.error(e,"DiffWithRevisionCommand"),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.dispose()}}}class Rs extends Si{constructor(){super(Ut.DiffWithWorking)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Ot.isUncommitted(i.commit.sha)){if(void 0===s.sha)return O.window.showInformationMessage("File matches the working tree");if(Ot.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await Wo.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:Ot.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,e)}}try{if(i.commit=await Wo.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return re.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),O.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await Wo.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return O.commands.executeCommand(Ut.DiffWith,r)}}var Ts,Es;!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(Ts||(Ts={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(Es||(Es={}));class Bs{constructor(e,t){this.uri=e,this.staged=t}}class Ns extends xi{constructor(){super(Ut.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new Bs(e.resourceUri,e.resourceGroupType===Es.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=o.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new Bs(e.resourceUri,e.resourceGroupType===Es.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Ts.BOTH_MODIFIED||t===Ts.INDEX_MODIFIED||t===Ts.MODIFIED}async execute(e={}){try{const t=await Wo.git.getRepoPath(void 0);if(!t)return Ti.showNoRepositoryWarningMessage("Unable to open changed files");const i=await Wo.git.getDiffTool(t);if(void 0===i){if(!await O.window.showWarningMessage("Unable to open file compare because there is no Git diff tool configured","View Git Docs"))return;return O.commands.executeCommand(j.Open,O.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await Wo.git.getStatusForRepo(t);if(void 0===i)return O.window.showWarningMessage("Unable to open changed files");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new Bs(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new Bs(t.uri,!1))}for(const s of e.files)Wo.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return re.error(e,"ExternalDiffCommand"),O.window.showErrorMessage("Unable to open external diff. See output channel for more details")}}}class As extends Si{constructor(){super(Ut.OpenChangedFiles)}async execute(e,t,i={}){t=fi(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to open changed files");const s=await Wo.git.getStatusForRepo(e);if(void 0===s)return O.window.showWarningMessage("Unable to open changed files");i.uris=o.filterMap(s.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Pi(e,{preserveFocus:!0,preview:!1});return}catch(e){return re.error(e,"OpenChangedFilesCommand"),O.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class Us extends Si{constructor(){super(Ut.OpenBranchesInRemote)}async preExecute(e,t={}){return Ci(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t),o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(o)try{const e=(await Wo.git.getRemotes(o)).filter(e=>void 0!==e.provider);return O.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:e})}catch(e){return re.error(e,"OpenBranchesInRemoteCommand"),O.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class Os extends Si{constructor(){super(Ut.OpenBranchInRemote)}async preExecute(e,t={}){return vi(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t),o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=await Wo.git.getBranches(o),t=await ts.show(e,`Show history for branch${Q.Ellipsis}`);if(void 0===t)return;if(t instanceof Gi)return;if(i.branch=t.branch.name,void 0===i.branch)return}const e=(await Wo.git.getRemotes(o)).filter(e=>void 0!==e.provider);return O.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"branch",branch:i.branch},remote:i.remote,remotes:e})}catch(e){return re.error(e,"OpenBranchInRemoteCommandArgs"),O.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class Ls extends Si{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Ut.OpenCommitInRemote,t)}constructor(){super(Ut.OpenCommitInRemote)}async preExecute(e,t={}){return wi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=void 0===e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(s,t,e.document.getText()):await Wo.git.getBlameForLine(s,t);if(void 0===o)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let r=o.commit;r.isUncommitted&&(r=r.with({sha:r.previousSha,fileName:r.previousFileName,previousSha:null,previousFileName:null})),i.sha=r.sha}const o=(await Wo.git.getRemotes(s.repoPath)).filter(e=>void 0!==e.provider);return O.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return re.error(e,"OpenCommitInRemoteCommand"),O.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class Is extends Si{constructor(){super(Ut.OpenFileInRemote)}async preExecute(e,t={range:!0}){return wi(e)?((t=Object.assign({},t)).range=!1,vi(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await Wo.git.getBranch(s.repoPath);void 0!==e&&(i.branch=e.name)}try{const o=(await Wo.git.getRemotes(s.repoPath)).filter(e=>void 0!==e.provider),r=i.range&&void 0!==e?new O.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return O.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch,fileName:s.getRelativePath(),range:r,sha:s.sha},remotes:o})}catch(e){return re.error(e,"OpenFileInRemoteCommand"),O.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class Ws extends Si{static getMarkdownCommandArgs(e,t,i){let s;if(e instanceof O.Uri){s={uri:e,line:i,annotationType:t}}else s=e;return super.getMarkdownCommandArgsCore(Ut.OpenFileRevision,s)}constructor(){super(Ut.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=fi(t,e)))return;const o=await Te.fromUri(t),r=`Open ${o.getFormattedPath()}${o.sha?` ${y.pad(Q.Dot,1,1)} ${o.shortSha}`:""} in revision ${Q.Ellipsis}`;s=ps.showProgress(r);const a=await Wo.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===a)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${a.maxCount} newer commits`},Ut.OpenFileRevision,[t,Object.assign({},i)]),s=f.last(a.commits.values());null!=s&&(n=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${a.maxCount} older commits`},Ut.OpenFileRevision,[new Te(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await ps.show(a,o,r,{pickerOnly:!0,progressCancellation:s,currentCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${Q.Space}$(git-commit) ${o.shortSha}`:""}`},Ut.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof Zi){const e=await h.execute();if(void 0===e)return;if(e instanceof Gi)return e.execute();i.uri=Te.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof Gi)return h.execute();i.uri=Te.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new O.Range(i.line,0,i.line,0));const o=await Pi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:Wo.annotations.showAnnotations(o,i.annotationType,i.line)}catch(e){return re.error(e,"OpenFileRevisionCommand"),O.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.dispose()}}}class Ms extends Si{constructor(){super(Ut.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length){return this.ensureRemoteBranchName(i),new is(i.remotes[0],i.resource).execute()}let e="";switch(i.resource.type){case de.Branch:this.ensureRemoteBranchName(i),e=`open ${i.resource.branch} branch in${Q.Ellipsis}`;break;case de.Commit:e=`open commit ${Ot.shortenSha(i.resource.sha)} in${Q.Ellipsis}`;break;case de.File:e=`open ${i.resource.fileName} in${Q.Ellipsis}`;break;case de.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof je)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,e=`open ${i.resource.fileName} ${y.pad(Q.Dot,1,1)} ${i.resource.commit.previousShortSha} in${Q.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,e=`open ${i.resource.fileName} ${y.pad(Q.Dot,1,1)} ${i.resource.commit.shortSha} in${Q.Ellipsis}`);else{const t=void 0===i.resource.sha?"":Ot.shortenSha(i.resource.sha),s=t?` ${y.pad(Q.Dot,1,1)} ${t}`:"";e=`open ${i.resource.fileName}${s} in${Q.Ellipsis}`}}if(1===i.remotes.length){return new is(i.remotes[0],i.resource).execute()}const t=await os.show(i.remotes,e,i.resource,i.goBackCommand);if(void 0===t)return;return t.execute()}catch(e){return re.error(e,"OpenInRemoteCommand"),O.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class Hs extends Si{constructor(){super(Ut.OpenRepoInRemote)}async preExecute(e,t={}){return Ci(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t),o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(o)try{const e=(await Wo.git.getRemotes(o)).filter(e=>void 0!==e.provider);return O.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:e})}catch(e){return re.error(e,"OpenRepoInRemoteCommand"),O.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class js extends Si{constructor(){super(Ut.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=fi(t,e)))return;if(i.uri=await Te.fromUri(t),i.uri instanceof Te&&i.uri.sha){const[e,t]=await Wo.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Te(O.Uri.file(Se.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new O.Range(i.line,0,i.line,0));const s=await Pi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:Wo.annotations.showAnnotations(s,i.annotationType,i.line)}catch(e){return re.error(e,"OpenWorkingFileCommand"),O.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class Gs extends xi{constructor(){super(Ut.ResetSuppressedWarnings)}async execute(){await jo.update(jo.name("advanced")("messages").value,void 0,O.ConfigurationTarget.Global)}}const Vs=/^([@~=:#])/,Qs=new Map([["@",Et.Author],["~",Et.Changes],["=",Et.ChangedOccurrences],[":",Et.Files],["#",Et.Sha]]);class Ks extends Di{constructor(){super(Ut.ShowCommitSearch)}async execute(e,t,i={}){const s=void 0===(t=fi(t,e))?void 0:await Te.fromUri(t);let o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(!o){const e=await vs.show(`Search for commits in which repository${Q.Ellipsis}`,i.goBackCommand);if(e instanceof Gi)return e.execute();if(void 0===e)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();o=e.repoPath}i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&void 0!==e&&void 0!==s){const t=await Wo.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){re.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await O.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=Vs.exec(i.search);t&&t[1]?(i.searchBy=Qs.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):Ot.isSha(i.search)?i.searchBy=Et.Sha:i.searchBy=Et.Message}void 0===i.searchBy&&(i.searchBy=Et.Message);let a=void 0;switch(i.searchBy){case Et.Author:a=`commits with an author matching '${i.search}'`;break;case Et.Changes:a=`commits with changes matching '${i.search}'`;break;case Et.ChangedOccurrences:a=`commits with changed occurrences matching '${i.search}'`;break;case Et.Files:a=`commits with files matching '${i.search}'`;break;case Et.Message:a=`commits with a message matching '${i.search}'`;break;case Et.Sha:a=`commits with an id matching '${i.search}'`}const n=us.showProgress(a);try{const e=await Wo.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const s=i.goBackCommand||new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to commit search`},Ut.ShowCommitSearch,[t,r]),h=await us.show(e,a,n,{goBackCommand:s,showAllCommand:void 0!==e&&e.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:s})]):void 0,showInResultsExplorerCommand:void 0!==e?new Ji(e,a):void 0});if(void 0===h)return;return h instanceof Gi?h.execute():O.commands.executeCommand(Ut.ShowQuickCommitDetails,h.commit.toGitUri(),{sha:h.commit.sha,commit:h.commit,goBackCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,2)} to search for ${a}`},Ut.ShowCommitSearch,[t,i])})}catch(e){return re.error(e,"ShowCommitSearchCommand"),O.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.dispose()}}}class zs extends ki{constructor(){super(Ut.ShowFileBlame)}async execute(e,t,i,s={}){if(void 0!==e)try{return void 0===s.type&&(s=Object.assign({},s,{type:R.Blame})),Wo.annotations.showAnnotations(e,s.type,void 0!==s.sha?s.sha:e.selection.active.line)}catch(e){return re.error(e,"ShowFileBlameCommand"),O.window.showErrorMessage("Unable to show file blame annotations. See output channel for more details")}}}class qs extends xi{constructor(){super(Ut.ShowLastQuickPick)}async execute(){const e=$i;if(void 0!==e)try{return O.commands.executeCommand(e.command,...e.args)}catch(e){return re.error(e,"ShowLastQuickPickCommand"),O.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class Ys extends Si{constructor(){super(Ut.ShowLineBlame)}async execute(e,t){try{return Wo.lineAnnotations.showAnnotations(e)}catch(e){return re.error(e,"ShowLineBlameCommand"),O.window.showErrorMessage("Unable to show line blame annotations. See output channel for more details")}}}class Xs extends Di{constructor(){super(Ut.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:gs.showProgress(i.branch);try{const e=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show branch history");if(void 0===i.branch){const t=await Wo.git.getBranches(e),s=await ts.show(t,`Show history for branch${Q.Ellipsis}`);if(void 0===s)return;if(s instanceof Gi)return s.execute();if(i.branch=s.branch.name,void 0===i.branch)return;o=gs.showProgress(i.branch)}if(void 0===i.log&&(i.log=await Wo.git.getLog(e,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return O.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const r=await gs.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===r)return;if(r instanceof Gi)return r.execute();const a=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to ${Q.Space}$(git-branch) ${i.branch} history`},Ut.ShowQuickBranchHistory,[t,Object.assign({},i)]);return O.commands.executeCommand(Ut.ShowQuickCommitDetails,r.commit.toGitUri(),{sha:r.commit.sha,commit:r.commit,repoLog:i.log,goBackCommand:a})}catch(e){return re.error(e,"ShowQuickBranchHistoryCommand"),O.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.dispose()}}}class Js extends Di{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Ut.ShowQuickCommitDetails,t)}constructor(){super(Ut.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,wi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);let o=s.repoPath,r=Se.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const e=await Wo.git.getBlameForLine(s,t);if(void 0===e)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(e.commit.isUncommitted)return Ti.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=e.commit.sha,o=e.commit.repoPath,r=e.commit.fileName,i.commit=e.commit}catch(e){return re.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),O.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await Wo.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Ti.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Ti.showCommitNotFoundWarningMessage("Unable to show commit details");void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand&&(i.goBackCommand=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to branch history`},Ut.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]));const e=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to details of ${Q.Space}$(git-commit) ${i.commit.shortSha}`},Ut.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),s=await hs.show(i.commit,t,i.goBackCommand,e,i.repoLog);if(void 0===s)return;return s instanceof rs?O.commands.executeCommand(Ut.ShowQuickCommitFileDetails,s.commit.toGitUri(),{commit:s.commit,sha:s.sha,goBackCommand:e}):s.execute()}catch(e){return re.error(e,"ShowQuickCommitDetailsCommand"),O.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class Zs extends Di{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Ut.ShowQuickCommitFileDetails,t)}constructor(){super(Ut.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,wi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const e=await Wo.git.getBlameForLine(o,t);if(void 0===e)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(e.commit.isUncommitted)return Ti.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=e.commit.sha,i.commit=e.commit,s=Se.relative(i.commit.repoPath,o.fsPath)}catch(e){return re.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),O.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await Wo.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Ti.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Ti.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await Wo.git.findWorkingFileName(i.commit);const e=Ot.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to details of ${Q.Space}$(git-commit) ${e}`},Ut.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const r=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to details of ${Q.Space}$(file-text) ${Se.basename(i.commit.fileName)} in ${Q.Space}$(git-commit) ${e}`},Ut.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),a=await ms.show(i.commit,t,i.goBackCommand,r,i.fileLog);if(void 0===a)return;return a instanceof Gi?a.execute():void 0}catch(e){return re.error(e,"ShowQuickCommitFileDetailsCommand"),O.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class eo extends Di{constructor(){super(Ut.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show branch history");const s=await Wo.git.getBranch(e);if(void 0===s)return;return O.commands.executeCommand(Ut.ShowQuickBranchHistory,t,{branch:s.name,goBackCommand:i.goBackCommand})}catch(e){return re.error(e,"ShowQuickCurrentBranchHistoryCommand"),O.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class to extends Di{constructor(){super(Ut.ShowQuickFileHistory)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return O.commands.executeCommand(Ut.ShowQuickCurrentBranchHistory);const s=await Te.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${y.pad(Q.Dot,1,1)} ${s.shortSha}`:""}`,r=ps.showProgress(o);try{if(void 0===i.log&&(i.log=await Wo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Ti.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let e=void 0;if(i.log.truncated){const o=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${i.log.maxCount} newer commits`},Ut.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),r=f.last(i.log.commits.values());null!=r&&(e=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${i.log.maxCount} older commits`},Ut.ShowQuickFileHistory,[new Te(t,r),Object.assign({},i,{log:void 0,nextPageCommand:o})]))}const a=await ps.show(i.log,s,o,{progressCancellation:r,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:e,showAllCommand:void 0!==i.log&&i.log.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new Xi(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===a)return;if(a instanceof Gi)return a.execute();const n=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${Se.basename(a.commit.fileName)}${s.sha?` from ${Q.Space}$(git-commit) ${s.shortSha}`:""}`},Ut.ShowQuickFileHistory,[t,i]);return O.commands.executeCommand(Ut.ShowQuickCommitFileDetails,a.commit.toGitUri(),{commit:a.commit,fileLog:i.log,sha:a.commit.sha,goBackCommand:n})}catch(e){return re.error(e,"ShowQuickFileHistoryCommand"),O.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.dispose()}}}class io extends Di{constructor(){super(Ut.ShowQuickRepoStatus)}async execute(e,t,i={}){t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show repository status");const s=await Wo.git.getStatusForRepo(e);if(void 0===s)return O.window.showWarningMessage("Unable to show repository status");const o=await bs.show(s,i.goBackCommand);if(void 0===o)return;return o instanceof Gi?o.execute():void 0}catch(e){return re.error(e,"ShowQuickRepoStatusCommand"),O.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class so extends Di{constructor(){super(Ut.ShowQuickStashList)}async execute(e,t,i={}){t=fi(t,e);const s=ys.showProgress("list");try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show stashed changes");const o=await Wo.git.getStashList(e);if(void 0===o)return O.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const r=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to stashed changes`},Ut.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),a=await ys.show(o,"list",s,i.goBackCommand,r);if(void 0===a)return;return a instanceof Gi?a.execute():O.commands.executeCommand(Ut.ShowQuickCommitDetails,a.commit.toGitUri(),{commit:a.commit,sha:a.commit.sha,goBackCommand:r})}catch(e){return re.error(e,"ShowQuickStashListCommand"),O.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.dispose()}}}class oo extends xi{constructor(){super(Ut.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return wi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await Wo.git.getActiveRepoPath();if(!i){const s=await vs.show(`Apply stashed changes from which repository${Q.Ellipsis}`,e.goBackCommand);if(s instanceof Gi)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to pick another repository`},Ut.StashApply,[e]),i=s.repoPath}const s=ys.showProgress("apply");try{const o=await Wo.git.getStashList(i);if(void 0===o)return O.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const r=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to apply stashed changes`},Ut.StashApply,[e]),a=await ys.show(o,"apply",s,t||e.goBackCommand,r);if(a instanceof Gi)return a.execute();if(void 0===a)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=a.commit}finally{s.dispose()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${Q.Ellipsis}`:e.stashItem.message,i=await O.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await Wo.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return re.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?O.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?O.window.showInformationMessage("Stash applied with conflicts"):O.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class ro extends xi{constructor(){super(Ut.StashDelete)}async preExecute(e,t={confirm:!0}){return wi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${Q.Ellipsis}`:e.stashItem.message,i=await O.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await Wo.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return re.error(e,"StashDeleteCommand"),O.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class ao extends xi{constructor(){super(Ut.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await Wo.git.getHighlanderRepoPath();if(!t){const i=await vs.show(`Stash changes for which repository${Q.Ellipsis}`,e.goBackCommand);if(i instanceof Gi)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await O.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await Wo.git.stashSave(t,e.message,e.uris)}catch(e){return re.error(e,"StashSaveCommand"),O.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class no extends xi{constructor(){super(Ut.ToggleCodeLens)}execute(){return Wo.codeLens.toggleCodeLens()}}class ho extends ki{constructor(){super(Ut.ToggleFileBlame)}async execute(e,t,i,s={}){if(void 0!==e){if(void 0!==i&&!te.equals(i,e.document.uri)){const t=O.window.visibleTextEditors.find(e=>te.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return void 0===s.type&&(s=Object.assign({},s,{type:R.Blame})),Wo.annotations.toggleAnnotations(e,s.type,void 0!==s.sha?s.sha:e.selection.active.line)}catch(e){return re.error(e,"ToggleFileBlameCommand"),O.window.showErrorMessage(`Unable to toggle file ${s.type} annotations. See output channel for more details`)}}}}class co extends ki{constructor(){super(Ut.ToggleFileHeatmap)}async execute(e,t,i){O.commands.executeCommand(Ut.ToggleFileBlame,i,{type:R.Heatmap})}}class lo extends ki{constructor(){super(Ut.ToggleFileRecentChanges)}async execute(e,t,i){O.commands.executeCommand(Ut.ToggleFileBlame,i,{type:R.RecentChanges})}}class mo extends Si{constructor(){super(Ut.ToggleLineBlame)}async execute(e,t){try{return Wo.lineAnnotations.toggleAnnotations(e)}catch(e){return re.error(e,"ToggleLineBlameCommand"),O.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const uo=/[`\>\#\*\_\-\+\.]/g;class go{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=d.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i){let s=`[\`${Q.DoubleArrowLeft}\`](${Ds.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===R.RecentChanges&&(i=R.Blame);const t=Te.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath),o=O.window.activeTextEditor.selection.active.line;s+=`[\`${Q.SquareWithTopShadow}\`](${Ws.getMarkdownCommandArgs(t,i||R.Blame,o)} "Blame Previous Revision") `}return t&&(s+=`[\`${Q.ArrowUpRight}\`](${Ls.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),s+=`[\`${Q.MiddleEllipsis}\`](${Zs.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s){null===t&&(t="MMMM Do, YYYY h:mma");let o="",r="",a="";e.isUncommitted?a=`\`${e.shortSha||"00000000"}\``:(r=`\n\n${this.getHoverCommandBar(e,i,s)}`,a=`[\`${e.shortSha}\`](${Js.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,o=`\n\n> ${o=e.message.replace(uo,"\\$&").replace(/^===/gm,`${Q.ZeroWidthSpace}===`).replace(/\n/g,"  \n")}`);const n=new O.MarkdownString(`${a} &nbsp; ![](${e.getGravatarUri(Wo.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${o}${r}`);return n.isTrusted=!0,n}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&Ot.isStagedUncommitted(t.sha)?`[\`Changes\`](${Ds.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${Q.Dash} &nbsp; [\`${e.previousShortSha}\`](${Js.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${Q.ArrowLeftRight} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Ds.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${Q.Dash} &nbsp; _uncommitted_\n${s}`:`[\`Changes\`](${Ds.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${Q.Dash} &nbsp; [\`${e.previousShortSha}\`](${Js.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${Q.ArrowLeftRight} [\`${e.shortSha}\`](${Js.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const r=new O.MarkdownString(o);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&Ot.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await Wo.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static detailsHover(e,t,i,s){return{hoverMessage:this.getHoverMessage(e,t,i,s)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const r=Rt.fromTemplate(t,e,i);return o.renderOptions.before.contentText=y.pad(r.replace(/ /g,Q.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let r=0;for(const e of s.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){r=-1;break}r+=e.truncateTo}r>=0&&(r+=y.width(y.interpolate(i,void 0)))>0&&(r+=3);let a=void 0,n=void 0;return t.enabled&&(a="solid",n="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new O.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:a,borderWidth:n,color:new O.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:r>=0?`${r}ch`:void 0,uncommittedColor:new O.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return go.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:Q.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static hover(e,t,i){const s={renderOptions:{before:Object.assign({},t)}};return this.applyHeatmap(s,e.date,i),s}static hoverRenderOptions(e){return e.enabled?{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:Q.ZeroWidthSpace,height:"100%",margin:"0 26px 0 0",textDecoration:"none"}:{before:void 0}}static trailing(e,t,i){const s=Rt.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new O.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new O.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:y.pad(s.replace(/ /g,Q.Space),1,1),fontWeight:"normal",fontStyle:"normal"}}}}static withRange(e,t,i){let s=e.range;return void 0!==t&&(s=s.with({start:s.start.with({character:t})})),void 0!==i&&(s=s.with({end:s.end.with({character:i})})),Object.assign({},e,{range:s})}}class po extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?Wo.git.getBlameForFileContents(this._uri,e.document.getText()):Wo.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?Wo.git.getBlameForFileContents(this._uri,this.editor.document.getText()):Wo.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=f.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=o.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new O.Range(e.line,0,e.line,H)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!Wo.config.hovers.enabled||!Wo.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(O.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(O.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=O.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await Wo.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const r=go.getHoverMessage(o||s,Wo.config.defaultDateFormat,await Wo.git.hasRemote(s.repoPath),this.annotationType);return new O.Hover(r,e.validateRange(new O.Range(t.line,0,t.line,H)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await go.changesHover(s,t.line,await Te.fromUri(e.uri));return new O.Hover(o.hoverMessage,e.validateRange(new O.Range(t.line,0,t.line,H)))}async getCommitForHover(e){if("line"!==Wo.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class fo extends po{async onProvideAnnotation(e,t){this.annotationType=R.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),r=Wo.config.blame,a=y.getTokensFromTemplate(r.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===r.dateFormat?Wo.config.defaultDateFormat:r.dateFormat,tokenOptions:a},h=Date.now(),c=r.avatars,l=Wo.config.defaultGravatarsStyle,d=r.separateLines,m=go.gutterRenderOptions(d,r.heatmap,r.format,n);this.decorations=[];const u=Object.create(null),g=c?Object.create(null):void 0;let p,f,v,w=!1;for(const e of i.lines){const t=e.line;v!==e.sha?(w=!1,v=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=u[e.sha])?(f=go.gutter(p,r.format,n,m),r.heatmap.enabled&&go.applyHeatmap(f,p.date,h),f.range=new O.Range(t,0,t,0),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g),u[e.sha]=f):(f=Object.assign({},f,{range:new O.Range(t,0,t,0)}),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g)))):(f=Object.assign({},f),r.compact&&!w&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:Q.Space.repeat(y.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),w=!0),f.range=new O.Range(t,0,t,0),this.decorations.push(f),c&&!r.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),c)){this.additionalDecorations=[];for(const e of s.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const C=process.hrtime(o);return re.log(`${1e3*C[0]+Math.floor(C[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(Wo.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:O.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class vo extends po{async onProvideAnnotation(e,t){this.annotationType=R.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),r=go.heatmapRenderOptions();this.decorations=[];const a=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=a[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=go.heatmap(n,o,r)).range=new O.Range(t,0,t,0),this.decorations.push(h),a[e.sha]=h):(h=Object.assign({},h,{range:new O.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return re.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(Wo.config.hovers.annotations),this.selection(e,i),!0}}class wo extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=R.RecentChanges;const t=await Wo.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await Wo.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=Wo.config,r=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new O.Range(new O.Position(i,0),new O.Position(i,H)));let a=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:go.getHoverMessage(t,r,await Wo.git.hasRemote(t.repoPath),this.annotationType),range:e}),o.hovers.annotations.changes&&(a=go.getHoverDiffMessage(t,this._uri,s))),this.decorations.push({hoverMessage:a,range:e})}}this.editor.setDecorations(this.highlightDecoration,this.decorations);const a=process.hrtime(s);return re.log(`${1e3*a[0]+Math.floor(a[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var Co;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(Co||(Co={}));const bo={blameAnnotation:O.window.createTextEditorDecorationType({isWholeLine:!0,rangeBehavior:O.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class yo extends O.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new O.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._disposable=O.Disposable.from(jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this._annotationProviders.forEach(async(e,t)=>await this.clearCore(t,Co.Disposing)),bo.blameAnnotation&&bo.blameAnnotation.dispose(),bo.blameHighlight&&bo.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=jo.initializing(e),i=Wo.config;if(t||jo.changed(e,jo.name("blame")("highlight").value)){bo.blameHighlight&&bo.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?bo.blameHighlight=O.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:O.OverviewRulerLane.Right,backgroundColor:e.locations.includes(B.Line)?new O.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(B.Overview)?new O.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):bo.blameHighlight=void 0}if(t||jo.changed(e,jo.name("recentChanges")("highlight").value)){bo.recentChangesHighlight&&bo.recentChangesHighlight.dispose();const e=i.recentChanges.highlight;bo.recentChangesHighlight=O.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:O.OverviewRulerLane.Right,backgroundColor:e.locations.includes(B.Line)?new O.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(B.Overview)?new O.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if(!t&&(jo.changed(e,jo.name("blame").value)||jo.changed(e,jo.name("recentChanges").value)||jo.changed(e,jo.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===R.RecentChanges?e.reset({decoration:bo.recentChangesAnnotation,highlightDecoration:bo.recentChangesHighlight}):e.annotationType===R.Blame?e.reset({decoration:bo.blameAnnotation,highlightDecoration:bo.blameHighlight}):this.showAnnotations(e.editor,R.Heatmap))}onActiveTextEditorChanged(e){if(void 0!==e&&!X(e))return;this._editor=e;const t=this.getProvider(e);void 0===t?(q(G.AnnotationStatus,void 0),this.detachKeyboardHook()):(q(G.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=O.window.activeTextEditor;void 0!==t&&this.clear(t,Co.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,Co.DocumentChanged)}onTextDocumentClosed(e){if(Wo.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,Co.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=f.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,Co.ColumnChanged)}}async onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}async clear(e,t=Co.User){this.clearCore(se.getCorrelationKey(e),t)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await Wo.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(se.getCorrelationKey(e))}async showAnnotations(e,t,i){if(void 0===e)return!1;if(this._editor=e,!(await Wo.tracker.getOrAdd(e.document)).isBlameable)return!1;const s=this.getProvider(e);return void 0!==s&&s.annotationType===t?(await s.selection(i),!0):void 0!==await O.window.withProgress({location:O.ProgressLocation.Window},async o=>{await q(G.AnnotationStatus,ie.Computing);const r=this.showAnnotationsCore(s,e,t,i,o),a=await r;return e===this._editor&&await q(G.AnnotationStatus,a&&a.status),r})}async toggleAnnotations(e,t,i){if(void 0!==e){const i=await Wo.tracker.getOrAdd(e.document);if(t===R.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.showAnnotations(e,t,i);const o=s.annotationType!==t;return await this.clearCore(s.correlationKey,Co.User),!!o&&this.showAnnotations(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await Wo.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,Co.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(re.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==se.getCorrelationKey(this._editor)||(await q(G.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(re.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case R.Blame:e="blame annotations";break;case R.Heatmap:e="heatmap annotations";break;case R.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${Se.basename(t.document.fileName)}`})}this.attachKeyboardHook();const r=await Wo.tracker.getOrAdd(t.document);let a=void 0;switch(i){case R.Blame:a=new fo(t,r,bo.blameAnnotation,bo.blameHighlight);break;case R.Heatmap:a=new vo(t,r,bo.blameAnnotation,void 0);break;case R.RecentChanges:a=new wo(t,r,void 0,bo.recentChangesHighlight)}if(void 0!==a&&await a.validate())return void 0!==e&&await this.clearCore(e.correlationKey,Co.User),this._annotationsDisposable||0!==this._annotationProviders.size||(re.log("Add listener registrations for annotations"),this._annotationsDisposable=O.Disposable.from(O.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveTextEditorChanged,50),this),O.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),O.window.onDidChangeVisibleTextEditors(p.debounce(this.onVisibleTextEditorsChanged,50),this),O.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),Wo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Wo.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(a.correlationKey,a),await a.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),a):void 0}}class xo extends O.CodeLens{constructor(e,t,i,s,o,r,a,n){super(r,n),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame&&this.blame()}}class So extends O.CodeLens{constructor(e,t,i,s,o,r,a){super(r),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame()}}class $o{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new O.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=jo.get(jo.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=jo.get(jo.name("codeLens").value,e.uri);let r=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==r&&(r={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}),r.symbolScopes=null!=r.symbolScopes?r.symbolScopes=r.symbolScopes.map(e=>e.toLowerCase()):[];const a=[],n=i.uri;let h,c;if(s)1===r.scopes.length&&r.scopes.includes(D.Document)||(c=await O.commands.executeCommand(j.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return a;if(1===r.scopes.length&&r.scopes.includes(D.Document)?h=e.isDirty?await this._git.getBlameForFileContents(n,e.getText()):await this._git.getBlameForFile(n):[h,c]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(n,e.getText()):this._git.getBlameForFile(n),O.commands.executeCommand(j.ExecuteDocumentSymbolProvider,e.uri)]),void 0===h||0===h.lines.length)return a}if(t.isCancellationRequested)return a;const l=p.once(()=>e.validateRange(new O.Range(0,1e6,1e6,1e6))),d=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==c&&(re.log("GitCodeLensProvider.provideCodeLenses:",`${c.length} symbol(s) found`),c.forEach(t=>this.provideCodeLens(a,e,t,r,l,h,n,o,s,d))),(r.scopes.includes(D.Document)||r.symbolScopes.includes("file"))&&!r.symbolScopes.includes("!file")&&!a.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=l();let t=void 0;(s||o.recentChange.enabled)&&(s||(t=p.once(()=>this._git.getBlameForRangeSync(h,n,e))),a.push(new xo(O.SymbolKind.File,n,t,e,!0,new O.Range(0,0,0,e.start.character),o.recentChange.command,d))),!s&&o.authors.enabled&&(void 0===t&&(t=p.once(()=>this._git.getBlameForRangeSync(h,n,e))),a.push(new So(O.SymbolKind.File,n,t,e,!0,new O.Range(0,1,0,e.start.character),o.authors.command)))}return a}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const r=O.SymbolKind[e.kind].toLowerCase();switch(e.kind){case O.SymbolKind.File:(t.scopes.includes(D.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&(s=i());break;case O.SymbolKind.Package:(t.scopes.includes(D.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case O.SymbolKind.Class:case O.SymbolKind.Interface:case O.SymbolKind.Module:case O.SymbolKind.Namespace:case O.SymbolKind.Struct:(t.scopes.includes(D.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;case O.SymbolKind.Constructor:case O.SymbolKind.Enum:case O.SymbolKind.Function:case O.SymbolKind.Method:(t.scopes.includes(D.Blocks)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;default:t.symbolScopes.includes(r)&&(o=!t.symbolScopes.includes(`!${r}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,r,a,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let m,u=0;if((h||n.recentChange.enabled)&&(h||(m=p.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new xo(i.kind,a,m,l,!1,d.range.with(new O.Position(d.range.start.line,u)),n.recentChange.command,c)),u++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case O.SymbolKind.File:break;case O.SymbolKind.Package:case O.SymbolKind.Module:case O.SymbolKind.Namespace:case O.SymbolKind.Class:case O.SymbolKind.Interface:case O.SymbolKind.Constructor:case O.SymbolKind.Method:case O.SymbolKind.Function:case O.SymbolKind.Enum:s=!0}s&&!h&&(void 0===m&&(m=p.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new So(i.kind,a,m,l,!1,d.range.with(new O.Position(d.range.start.line,u)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof xo?this.resolveGitRecentChangeCodeLens(e,t):e instanceof So?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=f.first(i.commits.values());let o=`${s.author}, ${s.formattedDate}`;switch(Wo.config.debug&&(o+=` [${O.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case $.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i,s);case $.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i,s);case $.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i,s);case $.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i,s);case $.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i,s);case $.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let o=`${s} ${s>1?"authors":"author"} (${f.first(i.authors.values()).name}${s>1?" and others":""})`;switch(Wo.config.debug&&(o+=` [${O.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${f.join(f.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case $.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i);case $.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i);case $.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i);case $.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i);case $.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i);case $.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:Ut.DiffWithPrevious,arguments:[O.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":$.ShowQuickCommitDetails,arguments:[O.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":$.ShowQuickCommitFileDetails,arguments:[O.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:$.ShowQuickCurrentBranchHistory,arguments:[O.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:$.ShowQuickFileHistory,arguments:[O.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:Ut.ToggleFileBlame,arguments:[O.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?jo.get(jo.name("strings")("codeLens")("unsavedChanges")("recentChangeAndAuthors").value):e.recentChange.enabled?jo.get(jo.name("strings")("codeLens")("unsavedChanges")("recentChangeOnly").value):jo.get(jo.name("strings")("codeLens")("unsavedChanges")("authorsOnly").value)}}$o.selector=[{scheme:V.File},{scheme:V.Git},{scheme:V.GitLensGit}];class Do extends O.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=O.Disposable.from(jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=jo.initializing(e),i=jo.name("codeLens").value;if(t||jo.changed(e,i,null)||jo.changed(e,jo.name("defaultDateStyle").value)||jo.changed(e,jo.name("defaultDateFormat").value)){t||re.log("CodeLens config changed; resetting CodeLens provider");const e=jo.get(i);e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,q(G.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(re.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=jo.get(jo.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||(re.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(re.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new $o(Wo.context,Wo.git,Wo.tracker),this._providerDisposable=O.Disposable.from(O.languages.registerCodeLensProvider($o.selector,this._provider),Wo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Wo.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}class ko extends O.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLine=new O.EventEmitter}get onDidChangeActiveLine(){return this._onDidChangeActiveLine.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||X(e))&&(this.reset(),this._editor=e,this._line=void 0!==e?e.selection.active.line:void 0,this.fireLineChanged({editor:e,line:this._line,reason:"editor"}))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!X(e.textEditor))return;const t=this._editor===e.textEditor?"line":"editor",i=e.selections[0].active.line;this._editor===e.textEditor&&this._line===i||(this.reset(),this._editor=e.textEditor,this._line=i,this.fireLineChanged({editor:this._editor,line:this._line,reason:t}))}get line(){return this._line}reset(){this.state=void 0}start(){void 0===this._disposable&&(this._disposable=O.Disposable.from(O.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveTextEditorChanged,0),this),O.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(O.window.activeTextEditor)))}stop(){void 0!==this._disposable&&(void 0!==this._lineChangedDebounced&&this._lineChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}fireLineChanged(e){void 0!==e.line?(void 0===this._lineChangedDebounced&&(this._lineChangedDebounced=p.debounce(e=>{O.window.activeTextEditor===e.editor&&e.line===(e.editor&&e.editor.selection.active.line)&&this._onDidChangeActiveLine.fire(e)},250,{track:!0})),this._lineChangedDebounced.pending()||this._onDidChangeActiveLine.fire(Object.assign({},e,{pending:!0})),this._lineChangedDebounced(e)):setImmediate(()=>{O.window.activeTextEditor===e.editor&&(void 0!==this._lineChangedDebounced&&this._lineChangedDebounced.cancel(),this._onDidChangeActiveLine.fire(e))})}}const Po=O.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:O.DecorationRangeBehavior.ClosedOpen});class _o{constructor(e){this._enabled=e}get enabled(){return!this.suspended&&this._enabled}get suspended(){return void 0!==this._suspendReason}reset(e){return!(this._enabled===e&&!this.suspended)&&(this._enabled=e,this._suspendReason=void 0,!0)}resume(e){const t=void 0!==this._suspendReason;return this._suspendReason=void 0,t}suspend(e){const t=void 0===this._suspendReason;return this._suspendReason=e,t}}class Fo extends O.Disposable{constructor(){super(()=>this.dispose()),this._lineTracker=new ko,this._disposable=O.Disposable.from(this._lineTracker,jo.onDidChange(this.onConfigurationChanged,this),Wo.annotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),O.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this.unregisterHoverProviders(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),this._lineTrackingDisposable&&this._lineTrackingDisposable.dispose(),this._statusBarItem&&this._statusBarItem.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=jo.initializing(e),i=jo.get();let s=!1;if((t||jo.changed(e,jo.name("currentLine").value))&&(s=!0,this._blameAnnotationState=void 0),(t||jo.changed(e,jo.name("hovers").value))&&(s=!0,this.unregisterHoverProviders()),t||jo.changed(e,jo.name("statusBar").value))if(s=!0,i.statusBar.enabled){const e="left"!==i.statusBar.alignment?O.StatusBarAlignment.Right:O.StatusBarAlignment.Left;void 0!==this._statusBarItem&&this._statusBarItem.alignment!==e&&(this._statusBarItem.dispose(),this._statusBarItem=void 0),this._statusBarItem=this._statusBarItem||O.window.createStatusBarItem(e,e===O.StatusBarAlignment.Right?1e3:0),this._statusBarItem.command=i.statusBar.command}else void 0!==this._statusBarItem&&(this._statusBarItem.dispose(),this._statusBarItem=void 0);if(!s)return;i.currentLine.enabled||i.statusBar.enabled||i.hovers.enabled&&i.hovers.currentLine.enabled||void 0!==this._blameAnnotationState&&this._blameAnnotationState.enabled?(this._lineTracker.start(),this._lineTrackingDisposable=this._lineTrackingDisposable||O.Disposable.from(this._lineTracker.onDidChangeActiveLine(this.onActiveLineChanged,this),Wo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Wo.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),Wo.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))):(this._lineTracker.stop(),void 0!==this._lineTrackingDisposable&&(this._lineTrackingDisposable.dispose(),this._lineTrackingDisposable=void 0)),this.refresh(O.window.activeTextEditor,{full:!0})}onActiveLineChanged(e){e.pending||void 0===e.line?this.clear(e.editor):this.refresh(e.editor)}onBlameStateChanged(e){e.blameable?this.refresh(e.editor):this.clear(e.editor)}onDebugSessionStarted(){this.suspendBlameAnnotations("debugging",O.window.activeTextEditor)&&(this._debugSessionEndDisposable=O.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resumeBlameAnnotations("debugging",O.window.activeTextEditor)}onDirtyIdleTriggered(e){const t=jo.get(jo.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||this.resumeBlameAnnotations("dirty",O.window.activeTextEditor)}async onDirtyStateChanged(e){e.dirty?this.suspendBlameAnnotations("dirty",O.window.activeTextEditor):this.resumeBlameAnnotations("dirty",O.window.activeTextEditor,{force:!0})}onFileAnnotationsToggled(){this.refresh(O.window.activeTextEditor)}async clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e),this._lineTracker.reset(),this.unregisterHoverProviders(),this._statusBarItem&&this._statusBarItem.hide()}async provideDetailsHover(e,t,i){if(void 0===this._editor||this._editor.document!==e)return;if(this._lineTracker.line!==t.line)return;const s=void 0!==this._lineTracker.state?this._lineTracker.state.commit:void 0;if(void 0===s)return;const o=await Wo.annotations.getAnnotationType(this._editor);if(void 0!==o&&Wo.config.hovers.annotations.details)return;const r="line"===Wo.config.hovers.currentLine.over,a=e.validateRange(new O.Range(t.line,r?0:H,t.line,H));if(!r&&a.start.character!==t.character)return;let n=void 0!==this._lineTracker.state?this._lineTracker.state.logCommit:void 0;void 0!==n||s.isUncommitted||void 0!==(n=await Wo.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(n.previousSha=s.previousSha,n.previousFileName=s.previousFileName,void 0!==this._lineTracker.state&&(this._lineTracker.state.logCommit=n));const h=await Wo.tracker.get(e);if(void 0===h)return;const c=go.getHoverMessage(n||s,Wo.config.defaultDateFormat,h.hasRemotes,o);return new O.Hover(c,a)}async provideChangesHover(e,t,i){if(void 0===this._editor||this._editor.document!==e)return;if(this._lineTracker.line!==t.line)return;const s=void 0!==this._lineTracker.state?this._lineTracker.state.commit:void 0;if(void 0===s)return;if(Wo.config.hovers.annotations.changes){if(void 0!==await Wo.annotations.getAnnotationType(this._editor))return}const o="line"===Wo.config.hovers.currentLine.over,r=e.validateRange(new O.Range(t.line,o?0:H,t.line,H));if(!o&&r.start.character!==t.character)return;const a=await Wo.tracker.get(e);if(void 0===a)return;const n=await go.changesHover(s,t.line,a.uri);return void 0!==n.hoverMessage?new O.Hover(n.hoverMessage,r):void 0}async show(e,t,i,s){if(void 0!==i.document){if(i.document.isDirty){const e=await Wo.tracker.get(i.document);void 0!==e&&e.setForceDirtyStateChangeOnNextDocumentChange()}this.updateStatusBar(e,i),this.updateTrailingAnnotation(e,t,i,s)}}async showAnnotations(e){this.setBlameAnnotationState(!0,e)}async toggleAnnotations(e){const t=this.getBlameAnnotationState();this.setBlameAnnotationState(!t.enabled,e)}async resumeBlameAnnotations(e,t,i={}){if(!(i.force||void 0!==this._blameAnnotationState&&this._blameAnnotationState.suspended))return;let s=!1;void 0!==this._blameAnnotationState&&(s=this._blameAnnotationState.resume(e)),void 0!==t&&(i.force||s)&&await this.refresh(t)}async suspendBlameAnnotations(e,t,i={}){const s=this.getBlameAnnotationState();if(void 0===this._blameAnnotationState&&!s.enabled)return!1;void 0===this._blameAnnotationState&&(this._blameAnnotationState=new _o(s.enabled));const o=this._blameAnnotationState.suspend(e);return void 0!==t&&(i.force||o)?(await this.refresh(t),!0):void 0}async setBlameAnnotationState(e,t){let i=!0;void 0===this._blameAnnotationState?this._blameAnnotationState=new _o(e):i=this._blameAnnotationState.reset(e),void 0!==t&&i&&await this.refresh(t)}clearAnnotations(e){void 0!==e&&e.setDecorations(Po,[])}getBlameAnnotationState(){if(void 0!==this._blameAnnotationState)return this._blameAnnotationState;const e=Wo.config;return{enabled:e.currentLine.enabled||e.statusBar.enabled||e.hovers.enabled&&e.hovers.currentLine.enabled}}async refresh(e,t={}){if(void 0===e&&void 0===this._editor)return;if(void 0===e||void 0===this._lineTracker.line)return void this.clear(this._editor);this._editor!==e&&(t.full=!0,this.clearAnnotations(this._editor),this._editor=e);const i=this.getBlameAnnotationState();if(i.enabled&&(void 0===t.trackedDocument&&(t.trackedDocument=await Wo.tracker.getOrAdd(e.document)),t.trackedDocument.isBlameable))return i.enabled&&Wo.config.hovers.enabled&&Wo.config.hovers.currentLine.enabled&&(t.full||void 0===this._hoverProviderDisposable)&&this.registerHoverProviders(e,Wo.config.hovers.currentLine),void 0===this._updateBlameDebounced&&(this._updateBlameDebounced=p.debounce(this.updateBlame,50,{track:!0})),void this._updateBlameDebounced(this._lineTracker.line,e,t.trackedDocument);await this.clear(e)}registerHoverProviders(e,t){if(this.unregisterHoverProviders(),void 0===e)return;if(!t.details&&!t.changes)return;const i=[];t.changes&&i.push(O.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.details&&i.push(O.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=O.Disposable.from(...i)}unregisterHoverProviders(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}async updateBlame(e,t,i){if(this._lineTracker.reset(),this._lineTracker.line!==e||this._updateBlameDebounced&&this._updateBlameDebounced.pending())return;const s=t.document.isDirty?await Wo.git.getBlameForLineContents(i.uri,e,t.document.getText()):await Wo.git.getBlameForLine(i.uri,e);let o,r;if(this._lineTracker.line===e&&i.isBlameable&&(!this._updateBlameDebounced||!this._updateBlameDebounced.pending())){this.getBlameAnnotationState().enabled&&(r=void 0===s?void 0:s.line,o=void 0===s?void 0:s.commit)}void 0===this._lineTracker.state&&(this._lineTracker.state=new he(o)),void 0===o||void 0===r?this.clear(t):this.show(o,r,t,e)}updateStatusBar(e,t){const i=Wo.config.statusBar;if(i.enabled&&void 0!==this._statusBarItem&&X(t)){switch(this._statusBarItem.text=`$(git-commit) ${Rt.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?Wo.config.defaultDateFormat:i.dateFormat})}`,i.command){case U.ToggleFileBlame:this._statusBarItem.tooltip="Toggle Blame Annotations";break;case U.DiffWithPrevious:this._statusBarItem.command=Ut.DiffLineWithPrevious,this._statusBarItem.tooltip="Compare Line Revision with Previous";break;case U.DiffWithWorking:this._statusBarItem.command=Ut.DiffLineWithWorking,this._statusBarItem.tooltip="Compare Line Revision with Working";break;case U.ToggleCodeLens:this._statusBarItem.tooltip="Toggle Git CodeLens";break;case U.ShowQuickCommitDetails:this._statusBarItem.tooltip="Show Commit Details";break;case U.ShowQuickCommitFileDetails:this._statusBarItem.tooltip="Show Line Commit Details";break;case U.ShowQuickFileHistory:this._statusBarItem.tooltip="Show File History";break;case U.ShowQuickCurrentBranchHistory:this._statusBarItem.tooltip="Show Branch History"}this._statusBarItem.show()}}async updateTrailingAnnotation(e,t,i,s){const o=Wo.config.currentLine;if(!o.enabled||!X(i))return;s=void 0===s?t.line:s;const r=go.trailing(e,o.format,null===o.dateFormat?Wo.config.defaultDateFormat:o.dateFormat);r.range=i.document.validateRange(new O.Range(s,H,s,H)),i.setDecorations(Po,[r])}}class Ro extends O.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new O.EventEmitter,this._onDidChangeTreeData=new O.EventEmitter,Wo.explorerCommands,O.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),O.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),O.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(F.Auto),this),O.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(F.List),this),O.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(F.Tree),this),O.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(Wo.config.gitExplorer.autoRefresh,!0),this),O.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(Wo.config.gitExplorer.autoRefresh,!1),this),O.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>this.setRenameFollowing(!0),this),O.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>this.setRenameFollowing(!1),this),O.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(T.History),this),O.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(T.Repository),this),Wo.context.subscriptions.push(O.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveEditorChanged,500),this),O.window.onDidChangeVisibleTextEditors(p.debounce(this.onVisibleEditorsChanged,500),this),jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onActiveEditorChanged(e){if(this._view!==T.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Bt.ActiveEditorChanged,t)}async onConfigurationChanged(e){const t=jo.initializing(e);if(!(t||jo.changed(e,jo.name("gitExplorer").value)||jo.changed(e,jo.name("explorers").value)||jo.changed(e,jo.name("defaultGravatarsStyle").value)||jo.changed(e,jo.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||jo.changed(e,jo.name("gitExplorer")("enabled").value))&&q(G.GitExplorer,this.config.enabled),(t||jo.changed(e,jo.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(Wo.config.gitExplorer.autoRefresh);let i=this._view;if((t||jo.changed(e,jo.name("gitExplorer")("view").value))&&((i=this.config.view)===T.Auto&&(i=Wo.context.workspaceState.get(z.GitExplorerView,T.Repository)),t))return this._view=i,q(G.GitExplorerView,this._view),this.setRoot(await this.getRootNode(O.window.activeTextEditor)),void(this._disposable=O.window.registerTreeDataProvider("gitlens.gitExplorer",this));this.reset(i,jo.changed(e,jo.name("advanced")("fileHistoryFollowsRenames").value))}onRepositoriesChanged(){this._view===T.Repository&&(this.clearRoot(),re.log(`GitExplorer[view=${this._view}].onRepositoriesChanged`),this.refresh(Bt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this._view===T.History&&(0!==e.length&&e.some(e=>e.document&&Wo.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Bt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&Wo.context.workspaceState.get(z.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},Wo.config.explorers,Wo.config.gitExplorer)}get folderResourceUri(){if(void 0!==O.workspace.workspaceFolders&&0!==O.workspace.workspaceFolders.length)return O.workspace.workspaceFolders[0].uri}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this._view===T.History?[new Wt(`No active file ${Q.Dash} no history to show`)]:[new Wt("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async getRootNode(e){switch(this._view){case T.History:{const t=this.getHistoryNode(e||O.window.activeTextEditor);return this._loading=t.then(e=>p.wait(0)),t}default:{const e=Wo.git.getRepositories();this._loading=e.then(e=>p.wait(0));const t=[...await e];if(0===t.length)return;if(1===t.length){const e=t[0];return new ai(Te.fromRepoPath(e.path),e,this,!0)}return new pi(t,this)}}}async getHistoryNode(e){if(void 0===e||0===O.window.visibleTextEditors.length||!O.window.visibleTextEditors.some(e=>e.document&&Wo.git.isTrackable(e.document.uri)))return;if(void 0===e.document||!Wo.git.isTrackable(e.document.uri))return this._root;const t=await Te.fromUri(e.document.uri),i=await Wo.git.getRepository(t);return void 0!==i?te.equals(t,this._root&&this._root.uri)?this._root:new gi(t,i,this):void 0}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Bt.Command),re.log(`GitExplorer[view=${this._view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this._view===T.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(O.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){re.log(`GitExplorer[view=${this._view}].refreshNode`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){this.setView(e),t&&void 0!==this._root&&this.clearRoot(),(this.setRoot(await this.getRootNode(O.window.activeTextEditor))||t)&&this.refresh(Bt.ViewChanged)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async setFilesLayout(e){return jo.update(jo.name("gitExplorer")("files")("layout").value,e,O.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}setView(e){this._view!==e&&(Wo.config.gitExplorer.view===T.Auto&&Wo.context.workspaceState.update(z.GitExplorerView,e),this._view=e,q(G.GitExplorerView,this._view),e!==T.Repository&&Wo.git.stopWatchingFileSystem())}async switchTo(e){this._view!==e&&this.reset(e,!0)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=Wo.context.workspaceState.get(z.GitExplorerAutoRefresh,!0):(i=t,await Wo.context.workspaceState.update(z.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=Wo.git.onDidChangeRepositories(this.onRepositoriesChanged,this),Wo.context.subscriptions.push(this._autoRefreshDisposable))),q(G.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Bt.AutoRefreshChanged)}setRenameFollowing(e){jo.updateEffective(jo.name("advanced")("fileHistoryFollowsRenames").value,e)}}class To extends O.Disposable{constructor(){super(()=>this.dispose()),O.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),O.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),O.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),O.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),O.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),O.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),O.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),O.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),O.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),O.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),O.commands.registerCommand("gitlens.explorers.compareSelectedAncestorWithWorking",this.compareSelectedAncestorWithWorking,this),O.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),O.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),O.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),O.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),O.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),O.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),O.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),O.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),O.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),O.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),O.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),O.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),O.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),O.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),O.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),O.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),O.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),O.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),O.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await Wo.git.checkoutFile(e.uri),this.openFile(e)}compareWithHead(e){e instanceof It&&Wo.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&Wo.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof It&&Wo.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareSelectedAncestorWithWorking(e){if(void 0===this._selection||!(e instanceof Kt))return;if(this._selection.repoPath!==e.repoPath||"branch"!==this._selection.type)return;const t=await Wo.git.getMergeBase(this._selection.repoPath,this._selection.ref,e.ref);void 0!==t&&Wo.resultsExplorer.showComparisonInResults(this._selection.repoPath,t,"")}compareWithSelected(e){void 0!==this._selection&&e instanceof It&&this._selection.repoPath===e.repoPath&&Wo.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof It))return;const t=e instanceof Kt?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},q(G.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,O.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return O.commands.executeCommand(Ut.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Pi(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Pi(t.uri||("D"===e.commit.status?Te.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Te.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Te.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:Ot.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Te.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>Te.fromFileStatus(e,i));for(const e of s)await Pi(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=o.filterMap(e.commit.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Pi(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return O.commands.executeCommand(Ut.DiffWith,o)}async openFileRevisionInRemote(e){return O.commands.executeCommand(Ut.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){if(!(e instanceof Kt))return;const t=`checkout ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof It))return;let t=!1,i=void 0;e instanceof Kt&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await O.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});if(void 0===s||""===s)return;const o=`branch ${t?"-t ":""}${s} ${e.ref}`;this.sendTerminalCommand(o,e.repoPath)}terminalDeleteBranch(e){if(!(e instanceof Kt))return;const t=e.branch.remote?`push ${e.branch.remote} :${e.ref}`:`branch -d ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalMergeBranch(e){if(!(e instanceof Kt))return;const t=`merge ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseBranch(e){if(!(e instanceof Kt))return;const t=`rebase -i ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof Kt){if(!e.branch.current||!e.branch.tracking)return;const t=`rebase -i ${e.branch.tracking}`;this.sendTerminalCommand(t,e.repoPath)}else if(e instanceof Zt){const t=`rebase -i ${e.status.upstream}`;this.sendTerminalCommand(t,e.status.repoPath)}}terminalSquashBranchIntoCommit(e){if(!(e instanceof Kt))return;const t=`merge --squash ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalCherryPickCommit(e){if(!(e instanceof Qt))return;const t=`cherry-pick -e ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseCommit(e){if(!(e instanceof Qt))return;const t=`rebase -i ${e.ref}^`;this.sendTerminalCommand(t,e.repoPath)}terminalResetCommit(e){if(!(e instanceof Qt))return;const t=`reset --soft ${e.ref}^`;this.sendTerminalCommand(t,e.repoPath)}terminalRevertCommit(e){if(!(e instanceof Qt))return;const t=`revert -e ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRemoveRemote(e){if(!(e instanceof qt))return;const t=`remote remove ${e.remote.name}`;this.sendTerminalCommand(t,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof It))return;const t=await O.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await O.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`tag ${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand(s,e.repoPath)}terminalDeleteTag(e){e instanceof oi&&this.sendTerminalCommand(`tag -d ${e.ref}`,e.repoPath)}ensureTerminal(){return void 0===this._terminal&&(this._terminal=O.window.createTerminal(W),this._disposable=O.window.onDidCloseTerminal(e=>{e.name===W&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),Wo.context.subscriptions.push(this._disposable)),this._terminal}sendTerminalCommand(e,t){const i=this.ensureTerminal();i.show(!1),i.sendText(`git -C ${t} ${e}`,!1)}}class Eo{async provideTextDocumentContent(e,t){const i=Te.fromRevisionUri(e);if(!i.repoPath||i.sha===Ot.deletedSha)return"";try{return await Wo.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return re.error(e,"GitContentProvider","getVersionedFileText"),void O.window.showErrorMessage(`Unable to show Git revision ${Ot.shortenSha(i.sha)} of '${Se.relative(i.repoPath,i.fsPath)}'`)}}}Eo.scheme=V.GitLensGit;class Bo extends O.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class No extends O.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Ao{async provideCodeLenses(e,t){const i=Te.fromRevisionUri(e.uri),s=[],o=await Wo.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new No(o.previousUri.fsPath,o,new O.Range(0,0,0,1))),s.push(new Bo(o.uri.fsPath,o,new O.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof Bo?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof No?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:Ut.DiffWithWorking,arguments:[O.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:Ut.DiffWithPrevious,arguments:[O.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}Ao.selector={scheme:V.GitLensGit};const Uo=O.Uri.parse("gitlens://authority/settings"),Oo=O.Uri.parse("gitlens://authority/welcome");class Lo extends O.Disposable{constructor(){super(()=>this.dispose()),this._onDidChange=new O.EventEmitter,this._scope=new Map,this._disposable=O.Disposable.from(O.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),O.workspace.registerTextDocumentContentProvider(Uo.scheme,this),O.commands.registerCommand("gitlens.showSettingsPage",this.showSettings,this),O.commands.registerCommand("gitlens.showWelcomePage",this.showWelcome,this),O.commands.registerCommand("gitlens.saveSettings",this.save,this))}get onDidChange(){return this._onDidChange.event}dispose(){this._disposable.dispose()}onTextDocumentClosed(e){this._scope.delete(e.uri.toString())}async provideTextDocumentContent(e){let t=(await O.workspace.openTextDocument(O.Uri.file(Wo.context.asAbsolutePath(`${e.path}.html`)))).getText().replace(/{{root}}/g,O.Uri.file(Wo.context.asAbsolutePath(".")).toString());return t.includes("'{{data}}'")&&(t=t.replace(/'{{data}}'/g,JSON.stringify({config:Wo.config,scope:this.getScope(e),scopes:this.getAvailableScopes(),uri:e.toString()}))),t}getAvailableScopes(){const e=[["user","User Settings"]];return void 0!==O.workspace.workspaceFolders&&O.workspace.workspaceFolders.length&&e.push(["workspace","Workspace Settings"]),e}getScope(e){return this._scope.get(e.toString())||"user"}refresh(e){re.log("PageProvider.refresh"),this._onDidChange.fire(e||Uo)}async save(e){re.log(`PageProvider.save: options=${JSON.stringify(e)}`),this._scope.set(e.uri,e.scope);const t="workspace"===e.scope?O.ConfigurationTarget.Workspace:O.ConfigurationTarget.Global;for(const i in e.changes){(await jo.inspect(i)).defaultValue===e.changes[i]?await jo.update(i,void 0,t):await jo.update(i,e.changes[i],t)}}async showSettings(){return await O.commands.executeCommand("vscode.previewHtml",Uo,O.ViewColumn.Active,"GitLens Settings")}async showWelcome(){return await O.commands.executeCommand("vscode.previewHtml",Oo,O.ViewColumn.Active,"Welcome to GitLens")}}class Io extends O.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new O.EventEmitter,Wo.explorerCommands,O.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),O.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),O.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(F.Auto),this),O.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(F.List),this),O.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(F.Tree),this),O.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),O.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),O.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),O.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),q(G.ResultsExplorerKeepResults,this.keepResults),Wo.context.subscriptions.push(jo.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(jo.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=jo.initializing(e);(t||jo.changed(e,jo.name("resultsExplorer").value)||jo.changed(e,jo.name("explorers").value)||jo.changed(e,jo.name("defaultGravatarsStyle").value))&&(t||0===this._roots.length||this.refresh(Bt.ConfigurationChanged),t&&(this._disposable=O.window.registerTreeDataProvider("gitlens.resultsExplorer",this)))}get config(){return Object.assign({},Wo.config.explorers,Wo.config.resultsExplorer)}get folderResourceUri(){if(void 0!==O.workspace.workspaceFolders&&0!==O.workspace.workspaceFolders.length)return O.workspace.workspaceFolders[0].uri}get keepResults(){return Wo.context.workspaceState.get(z.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),q(G.ResultsExplorer,!1)}async getChildren(e){return 0===this._roots.length?[new Wt("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Bt.Command),re.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){re.log("ResultsExplorer.refreshNode"),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){re.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}showComparisonInResults(e,t,i){this.addResults(new mi(e,t,i,this)),this.showResults()}showCommitInResults(e){this.addResults(new hi(e,this)),this.showResults()}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.addResults(new ci(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,r=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let a="";if(await Wo.git.getRepositoryCount()>1){const t=await Wo.git.getRepository(e.repoPath);a=` ${y.pad(Q.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${r.singular} for ${t.label}${a}`:`${0===s?"No":`${s}${o?"+":""}`} ${r.plural} for ${t.label}${a}`},p.seeded(i,e),this,Nt.SearchResults)),this.showResults()}async showResults(){await O.commands.executeCommand("workbench.view.explorer"),Ti.showResultExplorerInfoMessage(),q(G.ResultsExplorer,!0)}addResults(e){return!this._roots.includes(e)&&(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),!0)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return jo.update(jo.name("resultsExplorer")("files")("layout").value,e,O.ConfigurationTarget.Global)}setKeepResults(e){Wo.context.workspaceState.update(z.ResultsExplorerKeepResults,e),q(G.ResultsExplorerKeepResults,e)}}class Wo{static initialize(e,t){if(this._context=e,this._config=t,e.subscriptions.push(this._tracker=new ce),e.subscriptions.push(this._git=new Ot),this._tracker.initialize(),e.subscriptions.push(this._annotationController=new yo),e.subscriptions.push(this._currentLineController=new Fo),e.subscriptions.push(this._codeLensController=new Do),e.subscriptions.push(this._keyboard=new Ii),e.subscriptions.push(this._pageProvider=new Lo),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new Ro);else{let t;t=jo.onDidChange(i=>{jo.changed(i,jo.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new Ro))})}e.subscriptions.push(O.workspace.registerTextDocumentContentProvider(Eo.scheme,new Eo)),e.subscriptions.push(O.languages.registerCodeLensProvider(Ao.selector,new Ao))}static get annotations(){return this._annotationController}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=jo.get()),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new To),this._explorerCommands}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._currentLineController}static get pages(){return this._pageProvider}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new Io),this._resultsExplorer}static get tracker(){return this._tracker}static resetConfig(){this._config=void 0}}const Mo=new Proxy({},{get:(e,t,i)=>Mo});class Ho{constructor(){this._onDidChange=new O.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1}}static configure(e){e.subscriptions.push(O.workspace.onDidChangeConfiguration(jo.onConfigurationChanged,jo))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(L,null))return;Wo.resetConfig(),void 0!==Wo.pages&&Wo.pages.refresh(),jo.changed(e,jo.name("defaultGravatarsStyle").value)&&Ee.clear();const t=jo.name("keymap").value;jo.changed(e,t)&&q(G.KeyMap,this.get(t)),this._onDidChange.fire(e)}get(e,t,i){return void 0===i?O.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e):O.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e,i)}changed(e,t,i){return e.affectsConfiguration(`${L}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return O.workspace.getConfiguration(void 0===e?void 0:L,t).inspect(void 0===e?L:e)}async migrate(e,t,i){const s=jo.inspect(e);void 0!==s&&(void 0!==s.globalValue&&await this.update(t,i?i(s.globalValue):s.globalValue,O.ConfigurationTarget.Global),void 0!==s.workspaceValue&&await this.update(t,i?i(s.workspaceValue):s.workspaceValue,O.ConfigurationTarget.Workspace),void 0!==s.workspaceFolderValue&&await this.update(t,i?i(s.workspaceFolderValue):s.workspaceFolderValue,O.ConfigurationTarget.WorkspaceFolder))}name(e){return p.propOf(Mo,e)}update(e,t,i,s){return O.workspace.getConfiguration(L,i===O.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await jo.inspect(e,i);void 0!==s.workspaceFolderValue?await jo.update(e,t,O.ConfigurationTarget.WorkspaceFolder,i):void 0!==s.workspaceValue?await jo.update(e,t,O.ConfigurationTarget.Workspace):await jo.update(e,t,O.ConfigurationTarget.Global)}}const jo=new Ho;t.activate=async function(e){const t=process.hrtime();re.configure(e);const i=O.extensions.getExtension(M).packageJSON.version,o=O.workspace.getConfiguration("git",null).get("enabled",!0);if(!o)return re.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),void q(G.Enabled,o);Ho.configure(e);const r=e.globalState.get(K.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=x.fromString(t);try{if(1!==x.compare(i,x.from(6,1,2)))try{const t=jo.name("advanced")("messages").value,i=jo.get(t);let o=!1;for(const t of s.values(Ri)){const s=e.globalState.get(t);void 0!==s&&(o=!0,i[t]=s,e.globalState.update(t,void 0))}if(!o)return;await jo.update(t,i,O.ConfigurationTarget.Global)}catch(e){re.error(e,"migrateSettings - messages")}if(1!==x.compare(i,x.from(7,1,0))){const e=jo.name("advanced")("quickPick")("closeOnFocusOut").value;await jo.migrate(e,e,e=>!e)}if(1!==x.compare(i,x.from(7,3,0,"beta2"))&&await jo.migrate("advanced.maxQuickHistory",jo.name("advanced")("maxListItems").value),1!==x.compare(i,x.from(7,3,0,"beta4"))&&await jo.migrate("gitExplorer.gravatarsDefault",jo.name("defaultGravatarsStyle").value),1!==x.compare(i,x.from(7,5,9))&&(await jo.migrate("annotations.file.gutter.gravatars",jo.name("blame")("avatars").value),await jo.migrate("annotations.file.gutter.compact",jo.name("blame")("compact").value),await jo.migrate("annotations.file.gutter.dateFormat",jo.name("blame")("dateFormat").value),await jo.migrate("annotations.file.gutter.format",jo.name("blame")("format").value),await jo.migrate("annotations.file.gutter.heatmap.enabled",jo.name("blame")("heatmap")("enabled").value),await jo.migrate("annotations.file.gutter.heatmap.location",jo.name("blame")("heatmap")("location").value),await jo.migrate("annotations.file.gutter.lineHighlight.enabled",jo.name("blame")("highlight")("enabled").value),await jo.migrate("annotations.file.gutter.lineHighlight.locations",jo.name("blame")("highlight")("locations").value),await jo.migrate("annotations.file.gutter.separateLines",jo.name("blame")("separateLines").value),await jo.migrate("codeLens.locations",jo.name("codeLens")("scopes").value),await jo.migrate("codeLens.perLanguageLocations",jo.name("codeLens")("scopesByLanguage").value,e=>{const t=e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}));return t}),await jo.migrate("codeLens.customLocationSymbols",jo.name("codeLens")("symbolScopes").value),await jo.migrate("annotations.line.trailing.dateFormat",jo.name("currentLine")("dateFormat").value),await jo.migrate("blame.line.enabled",jo.name("currentLine")("enabled").value),await jo.migrate("annotations.line.trailing.format",jo.name("currentLine")("format").value),await jo.migrate("annotations.file.gutter.hover.changes",jo.name("hovers")("annotations")("changes").value),await jo.migrate("annotations.file.gutter.hover.details",jo.name("hovers")("annotations")("details").value),await jo.migrate("annotations.file.gutter.hover.details",jo.name("hovers")("annotations")("enabled").value),await jo.migrate("annotations.file.gutter.hover.wholeLine",jo.name("hovers")("annotations")("over").value,e=>e?"line":"annotation"),await jo.migrate("annotations.line.trailing.hover.changes",jo.name("hovers")("currentLine")("changes").value),await jo.migrate("annotations.line.trailing.hover.details",jo.name("hovers")("currentLine")("details").value),await jo.migrate("blame.line.enabled",jo.name("hovers")("currentLine")("enabled").value),await jo.migrate("annotations.line.trailing.hover.wholeLine",jo.name("hovers")("currentLine")("over").value,e=>e?"line":"annotation"),await jo.migrate("gitExplorer.gravatars",jo.name("explorers")("avatars").value),await jo.migrate("gitExplorer.commitFileFormat",jo.name("explorers")("commitFileFormat").value),await jo.migrate("gitExplorer.commitFormat",jo.name("explorers")("commitFormat").value),await jo.migrate("gitExplorer.stashFileFormat",jo.name("explorers")("stashFileFormat").value),await jo.migrate("gitExplorer.stashFormat",jo.name("explorers")("stashFormat").value),await jo.migrate("gitExplorer.statusFileFormat",jo.name("explorers")("statusFileFormat").value),await jo.migrate("recentChanges.file.lineHighlight.locations",jo.name("recentChanges")("highlight")("locations").value)),1!==x.compare(i,x.from(8,0,0,"beta2"))&&(await jo.migrate("debug",jo.name("outputLevel").value,e=>e?A.Debug:jo.get(jo.name("outputLevel").value)),await jo.migrate("debug",jo.name("debug").value,e=>void 0)),1!==x.compare(i,x.from(8,0,0,"rc"))){let e=jo.name("blame")("highlight")("locations").value;await jo.migrate(e,e,e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}),e=jo.name("recentChanges")("highlight")("locations").value,await jo.migrate(e,e,e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e})}}catch(e){re.error(e,"migrateSettings")}}(e,r);const a=jo.get();try{await Ot.initialize(a.advanced.git)}catch(e){return re.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await O.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${L}.${jo.name("advanced")("git").value}' is pointed to its installed location.`),void q(G.Enabled,!1)}Wo.initialize(e,a),q(G.KeyMap,Wo.config.keymap),Wo.context.subscriptions.push(new Ei),Wo.context.subscriptions.push(new As),Wo.context.subscriptions.push(new Ns),Wo.context.subscriptions.push(new Bi),Wo.context.subscriptions.push(new Ni),Wo.context.subscriptions.push(new xs),Wo.context.subscriptions.push(new Ss),Wo.context.subscriptions.push(new $s),Wo.context.subscriptions.push(new Ds),Wo.context.subscriptions.push(new ks),Wo.context.subscriptions.push(new Ps),Wo.context.subscriptions.push(new _s),Wo.context.subscriptions.push(new Fs),Wo.context.subscriptions.push(new Rs),Wo.context.subscriptions.push(new Us),Wo.context.subscriptions.push(new Os),Wo.context.subscriptions.push(new Ls),Wo.context.subscriptions.push(new Is),Wo.context.subscriptions.push(new Ws),Wo.context.subscriptions.push(new Ms),Wo.context.subscriptions.push(new Hs),Wo.context.subscriptions.push(new js),Wo.context.subscriptions.push(new _i),Wo.context.subscriptions.push(new zs),Wo.context.subscriptions.push(new Ys),Wo.context.subscriptions.push(new ho),Wo.context.subscriptions.push(new co),Wo.context.subscriptions.push(new lo),Wo.context.subscriptions.push(new mo),Wo.context.subscriptions.push(new Gs),Wo.context.subscriptions.push(new qs),Wo.context.subscriptions.push(new Xs),Wo.context.subscriptions.push(new eo),Wo.context.subscriptions.push(new Js),Wo.context.subscriptions.push(new Zs),Wo.context.subscriptions.push(new Ks),Wo.context.subscriptions.push(new to),Wo.context.subscriptions.push(new io),Wo.context.subscriptions.push(new so),Wo.context.subscriptions.push(new oo),Wo.context.subscriptions.push(new ro),Wo.context.subscriptions.push(new ao),Wo.context.subscriptions.push(new no),function(e){if(Ot.validateGitVersion(2,2))return;Ti.showUnsupportedGitVersionErrorMessage(e)}(Ot.getGitVersion()),async function(e,t){if(void 0===t)return re.log("GitLens first-time install"),void(Wo.config.showWhatsNewAfterUpgrades&&await O.commands.executeCommand(Ut.ShowWelcomePage));t!==e&&re.log(`GitLens upgraded from v${t} to v${e}`);if(!Wo.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,r]=t.split(".");if(i===o&&s===r)return;if(i<o||i===o&&s<r)return;await O.commands.executeCommand(Ut.ShowWelcomePage)}(i,r),e.globalState.update(K.GitLensVersion,i);const n=process.hrtime(t);re.log(`GitLens(v${i}) activated in ${1e3*n[0]+Math.floor(n[1]/1e6)} ms`)},t.deactivate=function(){}},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("tmp")},function(e,t){e.exports=require("copy-paste")}]);